(window.webpackJsonp=window.webpackJsonp||[]).push([[50],{359:function(e,a,v){"use strict";v.r(a);var _=v(6),t=Object(_.a)({},(function(){var e=this,a=e._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h2",{attrs:{id:"gpuimage-与-coreimage-对比"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#gpuimage-与-coreimage-对比"}},[e._v("#")]),e._v(" GPUImage 与 CoreImage 对比")]),e._v(" "),a("h3",{attrs:{id:"gpuimage"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#gpuimage"}},[e._v("#")]),e._v(" GPUImage")]),e._v(" "),a("p",[e._v("最低支持iOS4.0，iOS5.0之后就支持自定义滤镜")]),e._v(" "),a("p",[e._v("在低端机型上，GPUImage有更好的表现")]),e._v(" "),a("p",[e._v("GPUImage在视频处理上有更好的表现")]),e._v(" "),a("p",[e._v("GPUImage的代码完成公开，实现透明")]),e._v(" "),a("p",[e._v("可以根据自己的业务需求，定制更加复杂的管线操作。可定制程度高")]),e._v(" "),a("h3",{attrs:{id:"core-image"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#core-image"}},[e._v("#")]),e._v(" Core Image")]),e._v(" "),a("p",[e._v("官方框架，使用放心，维护方便。")]),e._v(" "),a("p",[e._v("支持CPU渲染，可以在后台继续处理和保存图片。")]),e._v(" "),a("p",[e._v("一些滤镜的性能更强劲。例如由Metal Performance Shaders 支持的模糊滤镜等")]),e._v(" "),a("p",[e._v("支持使用Metal 渲染图像。而Metal在iOS 平台上有更好的表现。")]),e._v(" "),a("p",[e._v("与Metal, SpriteKit, SceneKit, Core Animation 等更完美的配合。")]),e._v(" "),a("p",[e._v("支持图像识别功能。包括人脸识别、条形码识别、文本识别等。")]),e._v(" "),a("p",[e._v("支持自动增强图像效果，会分析图像的直方图，图像属性，脸部区域，然后通过一-组滤镜来改善图像效果。")]),e._v(" "),a("p",[e._v("支持对原生RAW格式图片的处理。")]),e._v(" "),a("p",[e._v("滤镜链的性能比GPUImage 高。")]),e._v(" "),a("p",[e._v("支持对大图进行处理，超过GPU纹理限制(4096 * 4096)的时候， 会自动拆分成几个小块处理(Automatic tiling)。GPUlmage当处理超过纹理限制的图像时候，会先做判断，压缩成最大纹理限制的图像，导致图像质量损失。")]),e._v(" "),a("h2",{attrs:{id:"gpuimage特性"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#gpuimage特性"}},[e._v("#")]),e._v(" GPUImage特性")]),e._v(" "),a("ul",[a("li",[a("p",[e._v("丰富的输入组件，摄像头、图片、视频、OpenGL纹理、二进制数据、UIElement（UIView， CALayer）")])]),e._v(" "),a("li",[a("p",[e._v("大量现成的内置滤镜")]),e._v(" "),a("ul",[a("li",[e._v("颜色类（亮度、色度、饱和度、对比度、曲线、白平衡 ...）")]),e._v(" "),a("li",[e._v("图像类（放射变换、裁剪、高斯模糊、毛玻璃效果 ...）")]),e._v(" "),a("li",[e._v("颜色混合类（差异混合、alpha混合、遮罩混合 ...）")]),e._v(" "),a("li",[e._v("效果类（像素化、素描效果、压花效果、球形玻璃效果 ...）")])])]),e._v(" "),a("li",[a("p",[e._v("丰富的输出自检UIView、视频文件、GPU纹理、二进制数据")])]),e._v(" "),a("li",[a("p",[e._v("灵活的滤镜链。滤镜效果之间可以相互串联，并联，调用管理想当灵活")])]),e._v(" "),a("li",[a("p",[e._v("接口易用。滤镜和OpenGL资源的创建及使用都做了统一的封装，简单易用，并且内置了一个cache模块实现了Framebuffer的复用")])]),e._v(" "),a("li",[a("p",[e._v("线程管理OpenGLContext不是多线程安全的，GPUImage创建了专门的contextQueue，所有的滤镜都会扔到统一线程中处理")])]),e._v(" "),a("li",[a("p",[e._v("轻松实现自定义滤镜效果，继承GPUImageFulter，自动获取上面的全部特性，无需关注上下文环境搭建，专注于效果的核心算法上即可")])])])])}),[],!1,null,null,null);a.default=t.exports}}]);