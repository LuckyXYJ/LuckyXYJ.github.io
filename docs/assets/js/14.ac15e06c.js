(window.webpackJsonp=window.webpackJsonp||[]).push([[14],{312:function(s,a,t){"use strict";t.r(a);var e=t(6),l=Object(e.a)({},(function(){var s=this,a=s._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[a("h2",{attrs:{id:"objc-class的结构"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#objc-class的结构"}},[s._v("#")]),s._v(" objc_class的结构")]),s._v(" "),a("p",[s._v("objc_class 继承与 objc_object")]),s._v(" "),a("p",[s._v("所有对象都是以objc_object为模板继承过来的")]),s._v(" "),a("p",[a("img",{attrs:{src:"http://xingyajie.oss-cn-hangzhou.aliyuncs.com/uPic/image-20220601103622311.png",alt:"image-20220601103622311"}})]),s._v(" "),a("h3",{attrs:{id:"isa"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#isa"}},[s._v("#")]),s._v(" ISA")]),s._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("union isa_t\n{\n    Class cls;\n    uintptr_t bits;\n    struct {\n        uintptr_t nonpointer        : 1; // 表示是否对 isa 指针开启指针优化\n        uintptr_t has_assoc         : 1; // 收否有oc关联对象\n        uintptr_t has_cxx_dtor      : 1; // 是否有c++析构函数\n        uintptr_t shiftcls          : 33; // 指针地址\n        uintptr_t magic             : 6;\t// 占用6位，用于调试器判断当前对象是真的对象还是没有初始化的空间\n        uintptr_t weakly_referenced : 1;  // 占用1位，标志对象是否被指向或者曾经指向一个 ARC 的弱变量，\n        uintptr_t deallocating      : 1;  // 占用1位 标志对象是否正在释放内存\n        uintptr_t has_sidetable_rc  : 1;  // 占用1位 是否使用sidetable存储引用计数\n        uintptr_t extra_rc          : 19; // 当表示该对象的引用计数值，实际上是引用计数值减 1\n    }\n}\n")])])]),a("h4",{attrs:{id:"结构体、联合体-共用体"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#结构体、联合体-共用体"}},[s._v("#")]),s._v(" 结构体、联合体(共用体)")]),s._v(" "),a("p",[s._v("struct 所有变量是‘共存’的，优点是‘有容乃大’，全面; 缺点是struct内存空间的分配是粗放的，不管用不用，全分配。")]),s._v(" "),a("p",[s._v("联合体(union)中是各变量是“互斥”的——缺点就是不够“包容”; 但优点是内存使用更为精细灵活，也节省了内存空间")]),s._v(" "),a("h4",{attrs:{id:"位域"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#位域"}},[s._v("#")]),s._v(" 位域")]),s._v(" "),a("p",[s._v("位域就是定义几个位表示一些信息，节约内存，内存优化的一种。isa_t要么是直接指向cls，要么是bits。")]),s._v(" "),a("h3",{attrs:{id:"class-rw-t"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#class-rw-t"}},[s._v("#")]),s._v(" class_rw_t")]),s._v(" "),a("p",[s._v("class_rw_t里面的methods、properties、protocols是二维数组，是可读可写的，包含了类的初始内容、分类的内容")]),s._v(" "),a("p",[a("img",{attrs:{src:"http://xingyajie.oss-cn-hangzhou.aliyuncs.com/uPic/image-20220605102634735.png",alt:"image-20220605102634735"}})]),s._v(" "),a("h3",{attrs:{id:"class-ro-t"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#class-ro-t"}},[s._v("#")]),s._v(" class_ro_t")]),s._v(" "),a("p",[s._v("class_ro_t里面的baseMethodList、baseProtocols、ivars、baseProperties是一维数组，是只读的，包含了类的初始内容")]),s._v(" "),a("p",[a("img",{attrs:{src:"http://xingyajie.oss-cn-hangzhou.aliyuncs.com/uPic/image-20220605102834487.png",alt:"image-20220605102834487"}})]),s._v(" "),a("h3",{attrs:{id:"method-t是对方法-函数的封装"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#method-t是对方法-函数的封装"}},[s._v("#")]),s._v(" method_t是对方法\\函数的封装")]),s._v(" "),a("p",[a("img",{attrs:{src:"http://xingyajie.oss-cn-hangzhou.aliyuncs.com/uPic/image-20220605102938675.png",alt:"image-20220605102938675"}})]),s._v(" "),a("p",[a("strong",[s._v("IMP")]),s._v("代表函数的具体实现")]),s._v(" "),a("p",[a("img",{attrs:{src:"http://xingyajie.oss-cn-hangzhou.aliyuncs.com/uPic/image-20220605103206801.png",alt:"image-20220605103206801"}})]),s._v(" "),a("p",[a("strong",[s._v("SEL")]),s._v("代表方法\\函数名，一般叫做选择器，底层结构跟char *类似。可以通过@selector()和sel_registerName()获得；可以通过sel_getName()和NSStringFromSelector()转成字符串；不同类中相同名字的方法，所对应的方法选择器是相同的")]),s._v(" "),a("p",[a("img",{attrs:{src:"http://xingyajie.oss-cn-hangzhou.aliyuncs.com/uPic/image-20220605103214960.png",alt:"image-20220605103214960"}})]),s._v(" "),a("p",[a("strong",[s._v("types")]),s._v("包含了函数返回值、参数编码的字符串")]),s._v(" "),a("p",[a("img",{attrs:{src:"http://xingyajie.oss-cn-hangzhou.aliyuncs.com/uPic/image-20220605103236384.png",alt:"image-20220605103236384"}})]),s._v(" "),a("h2",{attrs:{id:"iskindofclass-和-ismemberofclass"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#iskindofclass-和-ismemberofclass"}},[s._v("#")]),s._v(" isKindOfClass 和 isMemberOfClass")]),s._v(" "),a("h3",{attrs:{id:"ismemberofclass"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#ismemberofclass"}},[s._v("#")]),s._v(" "),a("strong",[s._v("isMemberOfClass")])]),s._v(" "),a("ul",[a("li",[s._v("调用者必须是传入的类的实例对象才返回YES")]),s._v(" "),a("li",[s._v("判断调用者是否是传入对象的实例，别弄反了，如 [ins isMemberOfClass:cls] ，意思是ins是否是cls的实例对象")]),s._v(" "),a("li",[s._v("不进行父类递归去查找判断")])]),s._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("+ (BOOL)isMemberOfClass:(Class)cls {\n    return object_getClass((id)self) == cls;\n}\n- (BOOL)isMemberOfClass:(Class)cls {\n    return [self class] == cls;\n}\n")])])]),a("h3",{attrs:{id:"iskindofclass"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#iskindofclass"}},[s._v("#")]),s._v(" "),a("strong",[s._v("isKindOfClass")])]),s._v(" "),a("ul",[a("li",[s._v("调用者是传入的类的实例对象，或者调用者是传入类的继承者链中的类的实例对象，则返回YES")]),s._v(" "),a("li",[s._v("判断调用者是否是传入对象的子类，别弄反了")]),s._v(" "),a("li",[s._v("去父类递归查找判断")])]),s._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("+ (BOOL)isKindOfClass:(Class)cls {\n    for (Class tcls = object_getClass((id)self); tcls; tcls = tcls->super_class) {\n        if(tcls == cls) return YES;\n    }\n    return NO;\n}\n-（BOOL)isKindOfClass:(Class)cls {\n    for(Class tcls = [self class]; tcls; tcls = tcls->super_class) {\n        if(tcls == cls) return YES;\n    }\n    return NO;\n}\n")])])]),a("h2",{attrs:{id:"cache-t-方法缓存"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#cache-t-方法缓存"}},[s._v("#")]),s._v(" cache_t 方法缓存")]),s._v(" "),a("p",[s._v("![Cache_t原理分析图](http://xingyajie.oss-cn-hangzhou.aliyuncs.com/uPic/Cooci %E5%85%B3%E4%BA%8ECache_t%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90%E5%9B%BE.png)")]),s._v(" "),a("p",[s._v("_buckets\nimp\nSEL\n_mask\n_flags 标志位\n_occupied 占用情况")]),s._v(" "),a("h2",{attrs:{id:"bits"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#bits"}},[s._v("#")]),s._v(" bits")]),s._v(" "),a("p",[s._v("uint32_t flags;\nuint32_t version;\nconst class_ro_t *ro;\nmethod_list_t *methods; 方法列表\nproperty_list_t *properties;   属性列表\nconst protocol_list_t *protocols; 协议列表\nClass firstSubclass;\nClass nextSiblingClass;\nchar *demangledName;")]),s._v(" "),a("h2",{attrs:{id:"成员变量-、属性-、实例变量"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#成员变量-、属性-、实例变量"}},[s._v("#")]),s._v(" 成员变量 、属性 、实例变量")]),s._v(" "),a("p",[s._v("属性 = 带下划线成员变量 + setter + getter 方法\n实例变量： 特殊的成员变量（类的实例化）")]),s._v(" "),a("h2",{attrs:{id:"方法-sel-imp"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#方法-sel-imp"}},[s._v("#")]),s._v(" 方法 sel + IMP")]),s._v(" "),a("p",[s._v("sel 方法编号\nIMP 函数指针地址")]),s._v(" "),a("p",[s._v("name + type + imp")]),s._v(" "),a("h2",{attrs:{id:"获取class的几个方法-object-getclass-class-objc-getmetaclass"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#获取class的几个方法-object-getclass-class-objc-getmetaclass"}},[s._v("#")]),s._v(" 获取Class的几个方法 object_getClass，class，objc_getMetaClass")]),s._v(" "),a("p",[a("code",[s._v("+ (Class)class;")]),s._v(" 返回本身\n"),a("code",[s._v("- (Class)class;")]),s._v(" 调用 object_getClass")]),s._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("Class object_getClass(id obj)\n{\n    if (obj) return obj->getIsa();\n    else return Nil;\n}\n")])])]),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v('Class objc_getMetaClass(const char *aClassName)\n{\n    Class cls;\n\n    if (!aClassName) return Nil;\n\n    cls = objc_getClass (aClassName);\n    if (!cls)\n    {\n        _objc_inform ("class `%s\' not linked into application", aClassName);\n        return Nil;\n    }\n\n    return cls->ISA();\n}\n')])])]),a("h2",{attrs:{id:"objc-getclass-object-getclass"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#objc-getclass-object-getclass"}},[s._v("#")]),s._v(" objc_getClass,object_getClass")]),s._v(" "),a("p",[s._v("Class objc_getClass(const char *aClassName)")]),s._v(" "),a("ul",[a("li",[s._v("传入字符串类名")]),s._v(" "),a("li",[s._v("返回对应的类对象")])]),s._v(" "),a("p",[s._v("Class object_getClass(id obj)")]),s._v(" "),a("ul",[a("li",[s._v("传入的obj可能是instance对象、class对象、meta-class对象")]),s._v(" "),a("li",[s._v("返回值\n"),a("ul",[a("li",[s._v("如果是instance对象，返回class对象")]),s._v(" "),a("li",[s._v("如果是class对象，返回meta-class对象")]),s._v(" "),a("li",[s._v("如果是meta-class对象，返回NSObject（基类）的meta-class对象")])])])]),s._v(" "),a("h2",{attrs:{id:"new与alloc-init的区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#new与alloc-init的区别"}},[s._v("#")]),s._v(" new与alloc/init的区别")]),s._v(" "),a("p",[s._v("new的源码")]),s._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("+ (id)new {\n    return [callAlloc(self, false/*checkNil*/) init];\n}\n")])])]),a("p",[s._v("Alloc")]),s._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("+ (id)alloc {\n    return _objc_rootAlloc(self);\n}\n\nid\n_objc_rootAlloc(Class cls)\n{\n    return callAlloc(cls, false/*checkNil*/, true/*allocWithZone*/);\n}\n")])])]),a("p",[s._v("callAlloc方法")]),s._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("callAlloc(Class cls, bool checkNil, bool allocWithZone=false)\n{\n#if __OBJC2__\n    if (slowpath(checkNil && !cls)) return nil;\n    if (fastpath(!cls->ISA()->hasCustomAWZ())) {\n        return _objc_rootAllocWithZone(cls, nil);\n    }\n#endif\n\n    // No shortcuts available.\n    if (allocWithZone) {\n        return ((id(*)(id, SEL, struct _NSZone *))objc_msgSend)(cls, @selector(allocWithZone:), nil);\n    }\n    return ((id(*)(id, SEL))objc_msgSend)(cls, @selector(alloc));\n}\n")])])]),a("p",[s._v("[className new]基本等同于[[className alloc] init]，区别只在于alloc分配内存的时候使用了zone。")]),s._v(" "),a("p",[s._v("Zone 作用 是给对象分配内存的时候，把关联的对象分配到一个相邻的内存区域内，以便于调用时消耗很少的代价，提升了程序处理速度")]),s._v(" "),a("p",[s._v("为什么不推荐使用new？")]),s._v(" "),a("ul",[a("li",[s._v("如果使用new的话，初始化方法被固定死只能调用init。不能调用initXXX")]),s._v(" "),a("li",[s._v("使用alloc init方法，我们可以重写init方法")])])])}),[],!1,null,null,null);a.default=l.exports}}]);