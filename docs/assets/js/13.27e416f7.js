(window.webpackJsonp=window.webpackJsonp||[]).push([[13],{358:function(t,a,i){"use strict";i.r(a);var e=i(6),_=Object(e.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h2",{attrs:{id:"category底层结构"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#category底层结构"}},[t._v("#")]),t._v(" Category底层结构")]),t._v(" "),a("p",[a("img",{attrs:{src:"http://xingyajie.oss-cn-hangzhou.aliyuncs.com/uPic/image-20220601174644778.png",alt:"image-20220601174644778"}})]),t._v(" "),a("h2",{attrs:{id:"category加载过程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#category加载过程"}},[t._v("#")]),t._v(" Category加载过程")]),t._v(" "),a("p",[t._v("1.通过Runtime加载某个类的所有Category数据")]),t._v(" "),a("p",[t._v("2.把所有Category的方法、属性、协议数据，合并到一个大数组中。后面参与编译的Category数据，会在数组的前面")]),t._v(" "),a("p",[t._v("3.将合并后的分类数据（方法、属性、协议），插入到类原来数据的前面")]),t._v(" "),a("h2",{attrs:{id:"load和initialize的区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#load和initialize的区别"}},[t._v("#")]),t._v(" load和initialize的区别")]),t._v(" "),a("h3",{attrs:{id:"load方法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#load方法"}},[t._v("#")]),t._v(" load方法")]),t._v(" "),a("ul",[a("li",[t._v("+load方法会在runtime加载类、分类时调用")]),t._v(" "),a("li",[t._v("每个类、分类的+load，在程序运行过程中只调用一次")]),t._v(" "),a("li",[t._v("+load方法是根据方法地址直接调用，并不是经过objc_msgSend函数调用")]),t._v(" "),a("li",[t._v("调用顺序\n"),a("ul",[a("li",[t._v("1、先调用类的+load\n"),a("ul",[a("li",[t._v("按照编译先后顺序调用（先编译，先调用）")]),t._v(" "),a("li",[t._v("调用子类的+load之前会先调用父类的+load")])])]),t._v(" "),a("li",[t._v("2、再调用分类的+load\n"),a("ul",[a("li",[t._v("按照编译先后顺序调用（先编译，先调用）")])])])])])]),t._v(" "),a("h3",{attrs:{id:"initialize方法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#initialize方法"}},[t._v("#")]),t._v(" initialize方法")]),t._v(" "),a("ul",[a("li",[t._v("+initialize方法会在类第一次接收到消息时调用")]),t._v(" "),a("li",[t._v("调用顺序\n"),a("ul",[a("li",[t._v("先调用父类的+initialize，再调用子类的+initialize")]),t._v(" "),a("li",[t._v("(先初始化父类，再初始化子类，每个类只会初始化1次)")])])])]),t._v(" "),a("h3",{attrs:{id:"initialize和-load对比"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#initialize和-load对比"}},[t._v("#")]),t._v(" +initialize和+load对比")]),t._v(" "),a("p",[t._v("+initialize是通过objc_msgSend进行调用的，所以有以下特点")]),t._v(" "),a("ul",[a("li",[t._v("如果子类没有实现+initialize，会调用父类的+initialize（所以父类的+initialize可能会被调用多次）")]),t._v(" "),a("li",[t._v("如果分类实现了+initialize，就覆盖类本身的+initialize调用")])]),t._v(" "),a("p",[t._v("+load方法是根据方法地址直接调用，并不是经过objc_msgSend函数调用")]),t._v(" "),a("h2",{attrs:{id:"添加成员变量"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#添加成员变量"}},[t._v("#")]),t._v(" 添加成员变量")]),t._v(" "),a("p",[t._v("默认情况下，因为分类底层结构的限制，不能添加成员变量到分类中。但可以通过关联对象来间接实现")]),t._v(" "),a("p",[t._v("关联对象提供了以下API：")]),t._v(" "),a("p",[a("strong",[t._v("添加关联对象")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("void objc_setAssociatedObject(id object, const void * key, id value, objc_AssociationPolicy policy)\n")])])]),a("table",[a("thead",[a("tr",[a("th",[a("strong",[t._v("objc_AssociationPolicy")])]),t._v(" "),a("th",[a("strong",[t._v("对应的修饰符")])])])]),t._v(" "),a("tbody",[a("tr",[a("td",[t._v("OBJC_ASSOCIATION_ASSIGN")]),t._v(" "),a("td",[t._v("assign")])]),t._v(" "),a("tr",[a("td",[t._v("OBJC_ASSOCIATION_RETAIN_NONATOMIC")]),t._v(" "),a("td",[t._v("strong, nonatomic")])]),t._v(" "),a("tr",[a("td",[t._v("OBJC_ASSOCIATION_COPY_NONATOMIC")]),t._v(" "),a("td",[t._v("copy, nonatomic")])]),t._v(" "),a("tr",[a("td",[t._v("OBJC_ASSOCIATION_RETAIN")]),t._v(" "),a("td",[t._v("strong, atomic")])]),t._v(" "),a("tr",[a("td",[t._v("OBJC_ASSOCIATION_COPY")]),t._v(" "),a("td",[t._v("copy, atomic")])])])]),t._v(" "),a("p",[a("strong",[t._v("获得关联对象")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("id objc_getAssociatedObject(id object, const void * key)\n")])])]),a("p",[a("strong",[t._v("移除所有的关联对象")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("void objc_removeAssociatedObjects(id object)\n")])])]),a("h3",{attrs:{id:"关联对象key"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#关联对象key"}},[t._v("#")]),t._v(" 关联对象key")]),t._v(" "),a("div",{staticClass:"language-objective-c extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('static void *MyKey = &MyKey;\n\nobjc_setAssociatedObject(obj, MyKey, value, OBJC_ASSOCIATION_RETAIN_NONATOMIC)\nobjc_getAssociatedObject(obj, MyKey)\n\n\nstatic char MyKey;\n\nobjc_setAssociatedObject(obj, &MyKey, value, OBJC_ASSOCIATION_RETAIN_NONATOMIC)\nobjc_getAssociatedObject(obj, &MyKey)\n\n\n使用属性名作为key\n\nobjc_setAssociatedObject(obj, @"property", value, OBJC_ASSOCIATION_RETAIN_NONATOMIC);\nobjc_getAssociatedObject(obj, @"property");\n\n\n使用get方法的@selecor作为key\n\nobjc_setAssociatedObject(obj, @selector(getter), value, OBJC_ASSOCIATION_RETAIN_NONATOMIC)\nobjc_getAssociatedObject(obj, @selector(getter))\n')])])]),a("h2",{attrs:{id:"关联对象原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#关联对象原理"}},[t._v("#")]),t._v(" 关联对象原理")]),t._v(" "),a("p",[t._v("实现关联对象技术的核心对象有")]),t._v(" "),a("ul",[a("li",[t._v("AssociationsManager")]),t._v(" "),a("li",[t._v("AssociationsHashMap")]),t._v(" "),a("li",[t._v("ObjectAssociationMap")]),t._v(" "),a("li",[t._v("ObjcAssociation")])]),t._v(" "),a("p",[a("img",{attrs:{src:"http://xingyajie.oss-cn-hangzhou.aliyuncs.com/uPic/image-20220601193652103.png",alt:"image-20220601193652103"}})]),t._v(" "),a("p",[t._v("关联对象并不是存储在被关联对象本身内存中")]),t._v(" "),a("p",[t._v("关联对象存储在全局的统一的一个AssociationsManager中")]),t._v(" "),a("p",[t._v("设置关联对象为nil，就相当于是移除关联对象")]),t._v(" "),a("p",[a("img",{attrs:{src:"http://xingyajie.oss-cn-hangzhou.aliyuncs.com/uPic/image-20220601193831823.png",alt:"image-20220601193831823"}})]),t._v(" "),a("h2",{attrs:{id:"分类与扩展"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#分类与扩展"}},[t._v("#")]),t._v(" 分类与扩展")]),t._v(" "),a("p",[t._v("分类 category:")]),t._v(" "),a("ul",[a("li",[t._v("1、专门给类添加新的方法")]),t._v(" "),a("li",[t._v("2、不能添加成员属性，添加了成员变量，也无法取到")]),t._v(" "),a("li",[t._v("3、可以通过runtime给分类添加属性")]),t._v(" "),a("li",[t._v("4、分类中用@property定义变量，只会生成变量的getter,setter方法的声明，不能生成方法实现和带下划线的成员变量")])]),t._v(" "),a("p",[t._v("扩展 extension:")]),t._v(" "),a("ul",[a("li",[t._v("1、是特殊的分类，也叫做匿名分类")]),t._v(" "),a("li",[t._v("2、可以给类添加成员属性，但是是私有变量")]),t._v(" "),a("li",[t._v("3、可以给类添加方法，也是私有方法")])])])}),[],!1,null,null,null);a.default=_.exports}}]);