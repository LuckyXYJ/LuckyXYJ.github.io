(window.webpackJsonp=window.webpackJsonp||[]).push([[20],{322:function(e,t,a){"use strict";a.r(t);var _=a(6),r=Object(_.a)({},(function(){var e=this,t=e._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h2",{attrs:{id:"ios内存布局"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#ios内存布局"}},[e._v("#")]),e._v(" iOS内存布局")]),e._v(" "),t("p",[e._v("内存由低到高分别为：")]),e._v(" "),t("ul",[t("li",[e._v("保留")]),e._v(" "),t("li",[e._v("代码段")]),e._v(" "),t("li",[e._v("数据段\n"),t("ul",[t("li",[e._v("常量区")]),e._v(" "),t("li",[e._v("全局区\n"),t("ul",[t("li",[e._v(".bss，已初始化全局、静态变量")]),e._v(" "),t("li",[e._v(".data，未初始化全局、静态变量")])])])])]),e._v(" "),t("li",[e._v("堆")]),e._v(" "),t("li",[e._v("栈")]),e._v(" "),t("li",[e._v("内核区")])]),e._v(" "),t("p",[t("strong",[e._v("代码段")]),e._v("：编译后的代码")]),e._v(" "),t("p",[t("strong",[e._v("数据段")]),e._v("：")]),e._v(" "),t("ul",[t("li",[e._v('字符串常量：比如NSString *str = @"123"')]),e._v(" "),t("li",[e._v("已初始化数据：已初始化的全局变量、静态变量等")]),e._v(" "),t("li",[e._v("未初始化数据：未初始化的全局变量、静态变量等")])]),e._v(" "),t("p",[t("strong",[e._v("栈")]),e._v("：函数调用开销，比如局部变量。分配的内存空间地址越来越小")]),e._v(" "),t("p",[t("strong",[e._v("堆")]),e._v("：通过alloc、malloc、calloc等动态分配的空间，分配的内存空间地址越来越大")]),e._v(" "),t("p",[t("strong",[e._v("内核区")]),e._v("：交给系统进行内核处理的区域")]),e._v(" "),t("h2",{attrs:{id:"oc对象内存管理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#oc对象内存管理"}},[e._v("#")]),e._v(" OC对象内存管理")]),e._v(" "),t("p",[e._v("在iOS中，使用"),t("strong",[e._v("引用计数")]),e._v("来管理OC对象的内存")]),e._v(" "),t("p",[e._v("一个新创建的OC对象引用计数默认是1，当引用计数减为0，OC对象就会销毁，释放其占用的内存空间")]),e._v(" "),t("p",[e._v("调用retain会让OC对象的引用计数+1，调用release会让OC对象的引用计数-1")]),e._v(" "),t("p",[e._v("内存管理的经验总结\n当调用alloc、new、copy、mutableCopy方法返回了一个对象，在不需要这个对象时，要调用release或者autorelease来释放它\n想拥有某个对象，就让它的引用计数+1；不想再拥有某个对象，就让它的引用计数-1")]),e._v(" "),t("p",[e._v("可以通过以下私有函数来查看自动释放池的情况\nextern void _objc_autoreleasePoolPrint(void);")]),e._v(" "),t("h3",{attrs:{id:"tagged-pointer"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#tagged-pointer"}},[e._v("#")]),e._v(" Tagged Pointer")]),e._v(" "),t("p",[e._v("Tagged Pointer技术，用于优化NSNumber、NSDate、NSString等小对象的存储。将数据直接存储在了指针中")]),e._v(" "),t("p",[e._v("objc_msgSend能识别Tagged Pointer，比如NSNumber的intValue方法，直接从指针提取数据，节省了以前的调用开销")]),e._v(" "),t("p",[e._v("判断是否是tagged pointer，iOS平台，最高有效位是1（第64bit）,pMac平台，最低有效位是1")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("BOOL isTaggedPointer(id pointer)\n{\n    return (long)(__bridge void *)pointer & 1; // 在Mac上位（1UL << 63）\n}\n")])])]),t("p",[e._v("以下两块代码有什么区别？")]),e._v(" "),t("div",{staticClass:"language-objective-c extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('// 代码1   EXC_BAD_ACCESS (code=1, address=0x66caa54d5420)\ndispatch_queue_t queue = dispatch_get_global_queue(0, 0);\nfor (int i = 0; i < 1000; i++) {\n  dispatch_async(queue, ^{\n  \tself.name = [NSString stringWithFormat:@"abcdefghijk"];\n  });\n}\n\n// 代码2\ndispatch_queue_t queue = dispatch_get_global_queue(0, 0);\nfor (int i = 0; i < 1000; i++) {\n\tdispatch_async(queue, ^{\n\t\tself.name = [NSString stringWithFormat:@"abc"];\n\t});\n}\n')])])]),t("h3",{attrs:{id:"引用计数的存储"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#引用计数的存储"}},[e._v("#")]),e._v(" 引用计数的存储")]),e._v(" "),t("p",[e._v("在64bit中，引用计数可以直接存储在优化过的isa指针中，也可能存储在SideTable类中")]),e._v(" "),t("p",[t("img",{attrs:{src:"http://xingyajie.oss-cn-hangzhou.aliyuncs.com/uPic/image-20220612111616435.png",alt:"image-20220612111616435"}})]),e._v(" "),t("p",[e._v("refcnts是一个存放着对象引用计数的散列表")]),e._v(" "),t("h4",{attrs:{id:"delloc"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#delloc"}},[e._v("#")]),e._v(" delloc")]),e._v(" "),t("p",[e._v("当一个对象要释放时，会自动调用dealloc，接下的调用轨迹是")]),e._v(" "),t("ul",[t("li",[e._v("dealloc")]),e._v(" "),t("li",[e._v("_objc_rootDealloc")]),e._v(" "),t("li",[e._v("rootDealloc")]),e._v(" "),t("li",[e._v("object_dispose")]),e._v(" "),t("li",[e._v("objc_destructInstance、free")])]),e._v(" "),t("p",[t("img",{attrs:{src:"http://xingyajie.oss-cn-hangzhou.aliyuncs.com/uPic/image-20220612111758693.png",alt:"image-20220612111758693"}})]),e._v(" "),t("h3",{attrs:{id:"自动释放池"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#自动释放池"}},[e._v("#")]),e._v(" 自动释放池")]),e._v(" "),t("p",[e._v("自动释放池的主要底层数据结构是：__AtAutoreleasePool、AutoreleasePoolPage")]),e._v(" "),t("p",[e._v("调用了autorelease的对象最终都是通过AutoreleasePoolPage对象来管理的")]),e._v(" "),t("p",[e._v("源码分析：clang重写@autoreleasepool，objc4源码：NSObject.mm")]),e._v(" "),t("p",[t("img",{attrs:{src:"http://xingyajie.oss-cn-hangzhou.aliyuncs.com/uPic/image-20220612111132711.png",alt:"image-20220612111132711"}})]),e._v(" "),t("p",[e._v("每个AutoreleasePoolPage对象占用4096字节内存，除了用来存放它内部的成员变量，剩下的空间用来存放autorelease对象的地址")]),e._v(" "),t("p",[e._v("所有的AutoreleasePoolPage对象通过双向链表的形式连接在一起")]),e._v(" "),t("p",[t("img",{attrs:{src:"http://xingyajie.oss-cn-hangzhou.aliyuncs.com/uPic/image-20220612111405594.png",alt:"image-20220612111405594"}})]),e._v(" "),t("p",[e._v("调用push方法会将一个POOL_BOUNDARY入栈，并且返回其存放的内存地址")]),e._v(" "),t("p",[e._v("调用pop方法时传入一个POOL_BOUNDARY的内存地址，会从最后一个入栈的对象开始发送release消息，直到遇到这个POOL_BOUNDARY")]),e._v(" "),t("p",[e._v("id *next指向了下一个能存放autorelease对象地址的区域")]),e._v(" "),t("h4",{attrs:{id:"runloop-和-autorelease"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#runloop-和-autorelease"}},[e._v("#")]),e._v(" RunLoop 和 Autorelease")]),e._v(" "),t("p",[e._v("iOS在主线程的Runloop中注册了2个Observer")]),e._v(" "),t("ul",[t("li",[e._v("第1个Observer监听了kCFRunLoopEntry事件，会调用objc_autoreleasePoolPush()")]),e._v(" "),t("li",[e._v("第2个Observer\n"),t("ul",[t("li",[e._v("监听了kCFRunLoopBeforeWaiting事件，会调用objc_autoreleasePoolPop()、objc_autoreleasePoolPush()")]),e._v(" "),t("li",[e._v("监听了kCFRunLoopBeforeExit事件，会调用objc_autoreleasePoolPop()")])])])]),e._v(" "),t("h2",{attrs:{id:"copy-和-mutablecopy"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#copy-和-mutablecopy"}},[e._v("#")]),e._v(" Copy 和 mutableCopy")]),e._v(" "),t("p",[e._v("iOS提供了2个拷贝方法")]),e._v(" "),t("p",[e._v("1.copy，不可变拷贝，产生不可变副本")]),e._v(" "),t("p",[e._v("2.mutableCopy，可变拷贝，产生可变副本")]),e._v(" "),t("p",[e._v("深拷贝和浅拷贝")]),e._v(" "),t("p",[e._v("1.深拷贝：内容拷贝，产生新的对象")]),e._v(" "),t("p",[e._v("2.浅拷贝：指针拷贝，没有产生新的对象")]),e._v(" "),t("table",[t("thead",[t("tr",[t("th"),e._v(" "),t("th",[e._v("copy")]),e._v(" "),t("th",[e._v("mutableCopy")])])]),e._v(" "),t("tbody",[t("tr",[t("td",[e._v("NSString")]),e._v(" "),t("td",[e._v("NSString  浅拷贝")]),e._v(" "),t("td",[e._v("NSMutableString  深拷贝")])]),e._v(" "),t("tr",[t("td",[e._v("NSMutableString")]),e._v(" "),t("td",[e._v("NSString  深拷贝")]),e._v(" "),t("td",[e._v("NSMutableString  深拷贝")])]),e._v(" "),t("tr",[t("td",[e._v("NSArray")]),e._v(" "),t("td",[e._v("NSArray  浅拷贝")]),e._v(" "),t("td",[e._v("NSMutableArray  深拷贝")])]),e._v(" "),t("tr",[t("td",[e._v("NSMutableArray")]),e._v(" "),t("td",[e._v("NSArray  深拷贝")]),e._v(" "),t("td",[e._v("NSMutableArray  深拷贝")])]),e._v(" "),t("tr",[t("td",[e._v("NSDictionary")]),e._v(" "),t("td",[e._v("NSDictionary  浅拷贝")]),e._v(" "),t("td",[e._v("NSMutableDictionary  深拷贝")])]),e._v(" "),t("tr",[t("td",[e._v("NSMutableDictionary")]),e._v(" "),t("td",[e._v("NSDictionary  深拷贝")]),e._v(" "),t("td",[e._v("NSMutableDictionary  深拷贝")])])])]),e._v(" "),t("h2",{attrs:{id:"block-nstimer循环引用区别与解决方案"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#block-nstimer循环引用区别与解决方案"}},[e._v("#")]),e._v(" Block，NSTimer循环引用区别与解决方案")]),e._v(" "),t("p",[e._v("block解决方案：\n1、__block修饰，并在里面手动释放\n2、unsafe_unretain\n2、__weak 修饰")]),e._v(" "),t("p",[e._v("NSTimer:\n1、在合适的时机手动停止NSTimer并置空，- (void)didMoveToParentViewController:(UIViewController *)parent\n2、第三方中介者+方法交换，delloc中调用NSTimer释放和置空\n3、自定义Timer作为第三方中介，内部常见NSTimer，原理同方法2\n4、NSProxy作为第三方中介， 消息转发。")]),e._v(" "),t("p",[e._v("timer循环引用：self -> timer -> weakSelf -> self,当前的timer捕获的是B界面的内存，即vc对象的内存，即weakSelf表示的是vc对象")]),e._v(" "),t("p",[e._v("Block循环引用：self -> block -> weakSelf -> self，当前的block捕获的是指针地址，即weakSelf表示的是指向self的临时变量的指针地址")]),e._v(" "),t("h2",{attrs:{id:"arc-mrc内存管理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#arc-mrc内存管理"}},[e._v("#")]),e._v(" ARC，MRC内存管理")]),e._v(" "),t("p",[e._v("retain\n引用计数+1,如果引用计数出现上溢出，那么我们开始分开存储，一半存到散列表\nrelase\n引用计数-1,如果引用计数出现下溢出，就去散列表借来的引用计数 - 1,存到extra_rc release 就算借散列表的引用计数过来，还是下溢出，那么就调用dealloc\ndealloc\n根据当前对象的状态是否直接调用free()释放\n是否存在C++的析构函数、移除这个对象的关联属性\n将指向该对象的弱引用指针置为nil\n从弱引用表中擦除对该对象的引用计数\nweak\n首先我们知道有一个非常牛逼的家伙-sideTable\n得到sideTable的weakTable 弱引用表\n创建一个weak_entry_t\n把referent加入到weak_entry_t的数组inline_referrers\n把weak_table扩容一下\n把new_entry加入到weak_table中")])])}),[],!1,null,null,null);t.default=r.exports}}]);