(window.webpackJsonp=window.webpackJsonp||[]).push([[21],{326:function(t,_,e){"use strict";e.r(_);var a=e(6),r=Object(a.a)({},(function(){var t=this,_=t._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("h2",{attrs:{id:"ios多线程方案"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#ios多线程方案"}},[t._v("#")]),t._v(" iOS多线程方案")]),t._v(" "),_("table",[_("thead",[_("tr",[_("th",[_("strong",[t._v("技术方案")])]),t._v(" "),_("th",[_("strong",[t._v("简介")])]),t._v(" "),_("th",[_("strong",[t._v("语言")])]),t._v(" "),_("th",[_("strong",[t._v("线程生命周期")])]),t._v(" "),_("th",[_("strong",[t._v("使用频率")])])])]),t._v(" "),_("tbody",[_("tr",[_("td",[t._v("pthread")]),t._v(" "),_("td",[t._v("通用多线程API"),_("br"),t._v("适用于unix/linux/windows等系统"),_("br"),t._v("跨平台/可移植"),_("br"),t._v("使用难度大")]),t._v(" "),_("td",[t._v("C")]),t._v(" "),_("td",[t._v("程序员管理")]),t._v(" "),_("td",[t._v("不用")])]),t._v(" "),_("tr",[_("td",[t._v("NSThread")]),t._v(" "),_("td",[t._v("使用更加面向对象"),_("br"),t._v("简单易用，可直接操作线程对象")]),t._v(" "),_("td",[t._v("OC")]),t._v(" "),_("td",[t._v("程序员管理")]),t._v(" "),_("td",[t._v("偶尔使用"),_("br"),t._v(" - 线程保活"),_("br"),t._v(" - 定时器")])]),t._v(" "),_("tr",[_("td",[t._v("GCD")]),t._v(" "),_("td",[t._v("旨在替代NSThread"),_("br"),t._v("充分利用设备多核")]),t._v(" "),_("td",[t._v("C")]),t._v(" "),_("td",[t._v("自动管理")]),t._v(" "),_("td",[t._v("经常使用")])]),t._v(" "),_("tr",[_("td",[t._v("NSOperation")]),t._v(" "),_("td",[t._v("基于GCD"),_("br"),t._v("比GCD多了一些更简单实用的功能"),_("br"),t._v("使用更加面向对象")]),t._v(" "),_("td",[t._v("OC")]),t._v(" "),_("td",[t._v("自动管理")]),t._v(" "),_("td",[t._v("经常使用")])])])]),t._v(" "),_("h2",{attrs:{id:"gcd"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#gcd"}},[t._v("#")]),t._v(" GCD")]),t._v(" "),_("h3",{attrs:{id:"同步"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#同步"}},[t._v("#")]),t._v(" 同步：")]),t._v(" "),_("p",[_("code",[t._v("​ dispatch_sync(dispatch_queue_t queue, dispatch_block_t block);")])]),t._v(" "),_("h3",{attrs:{id:"异步"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#异步"}},[t._v("#")]),t._v(" 异步：")]),t._v(" "),_("p",[_("code",[t._v("​ dispatch_async(dispatch_queue_t queue, dispatch_block_t block);")])]),t._v(" "),_("h3",{attrs:{id:"并发队列"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#并发队列"}},[t._v("#")]),t._v(" 并发队列：")]),t._v(" "),_("p",[_("code",[t._v('​ dispatch_queue_t queue = dispatch_queue_create("myqueu2", DISPATCH_QUEUE_CONCURRENT);')])]),t._v(" "),_("p",[_("code",[t._v("dispatch_queue_t queue1 = dispatch_get_global_queue(intptr_t identifier, uintptr_t flags);;")])]),t._v(" "),_("p",[_("strong",[t._v("全局队列")]),t._v("有默认有四个，根据第一个参数"),_("strong",[t._v("identifier")]),t._v("可以获取不同的全局队列。"),_("strong",[t._v("flags")]),t._v("留作将来使用。传递除0以外的任何值都可能导致返回值为NULL。")]),t._v(" "),_("ul",[_("li",[t._v("#define DISPATCH_QUEUE_PRIORITY_HIGH 2")]),t._v(" "),_("li",[t._v("#define DISPATCH_QUEUE_PRIORITY_DEFAULT 0")]),t._v(" "),_("li",[t._v("#define DISPATCH_QUEUE_PRIORITY_LOW (-2)")]),t._v(" "),_("li",[t._v("#define DISPATCH_QUEUE_PRIORITY_BACKGROUND INT16_MIN")])]),t._v(" "),_("h3",{attrs:{id:"串行队列"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#串行队列"}},[t._v("#")]),t._v(" 串行队列：")]),t._v(" "),_("p",[_("code",[t._v('dispatch_queue_t queue = dispatch_queue_create("myqueu", DISPATCH_QUEUE_SERIAL);')])]),t._v(" "),_("p",[_("code",[t._v("dispatch_queue_t queue1 = dispatch_get_main_queue();")])]),t._v(" "),_("p",[_("strong",[t._v("主队列是特殊的串行队列")])]),t._v(" "),_("h3",{attrs:{id:"同步异步任务与并发串行队列"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#同步异步任务与并发串行队列"}},[t._v("#")]),t._v(" 同步异步任务与并发串行队列")]),t._v(" "),_("p",[t._v("同步和异步主要影响：能不能开启新的线程")]),t._v(" "),_("ul",[_("li",[t._v("同步：在当前线程中执行任务，不具备开启新线程的能力")]),t._v(" "),_("li",[t._v("异步：在新的线程中执行任务，具备开启新线程的能力")])]),t._v(" "),_("p",[t._v("并发和串行主要影响：任务的执行方式")]),t._v(" "),_("ul",[_("li",[t._v("并发：多个任务并发（同时）执行")]),t._v(" "),_("li",[t._v("串行：一个任务执行完毕后，再执行下一个任务")])]),t._v(" "),_("p",[t._v("主队列是特殊的串行队列")]),t._v(" "),_("table",[_("thead",[_("tr",[_("th"),t._v(" "),_("th",[t._v("并发队列")]),t._v(" "),_("th",[t._v("串行队列")]),t._v(" "),_("th",[t._v("主队列")])])]),t._v(" "),_("tbody",[_("tr",[_("td",[t._v("同步 sync")]),t._v(" "),_("td",[_("strong",[t._v("没有")]),t._v("开启新线程"),_("br"),_("strong",[t._v("串行")]),t._v("执行任务")]),t._v(" "),_("td",[_("strong",[t._v("没有")]),t._v("开启新线程"),_("br"),_("strong",[t._v("串行")]),t._v("执行任务")]),t._v(" "),_("td",[_("strong",[t._v("没有")]),t._v("开启新线程")])]),t._v(" "),_("tr",[_("td",[t._v("异步 async")]),t._v(" "),_("td",[_("strong",[t._v("开启")]),t._v("新线程"),_("br"),_("strong",[t._v("并发")]),t._v("执行任务")]),t._v(" "),_("td",[_("strong",[t._v("开启")]),t._v("新线程"),_("br"),_("strong",[t._v("串行")]),t._v("执行任务")]),t._v(" "),_("td",[_("strong",[t._v("没有")]),t._v("开启新线程"),_("br"),_("strong",[t._v("串行")]),t._v("执行任务")])])])]),t._v(" "),_("p",[_("strong",[t._v("使用sync函数往当前串行队列中添加任务，会卡住当前的串行队列（产生死锁）")])]),t._v(" "),_("h2",{attrs:{id:"队列-组group-的使用"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#队列-组group-的使用"}},[t._v("#")]),t._v(" 队列 组Group 的使用")]),t._v(" "),_("p",[t._v("异步并发执行任务1、任务2，等任务1、任务2都执行完毕后，再回到主线程执行任务3")]),t._v(" "),_("p",[_("img",{attrs:{src:"http://xingyajie.oss-cn-hangzhou.aliyuncs.com/uPic/image-20220609094830991.png",alt:"image-20220609094830991"}})]),t._v(" "),_("h2",{attrs:{id:"栅栏函数-dispatch-barrier-async"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#栅栏函数-dispatch-barrier-async"}},[t._v("#")]),t._v(" 栅栏函数 "),_("strong",[t._v("dispatch_barrier_async")])]),t._v(" "),_("p",[t._v("这个函数传入的并发队列必须是自己通过dispatch_queue_cretate创建的")]),t._v(" "),_("p",[t._v("如果传入的是一个串行或是一个全局的并发队列，那这个函数便等同于dispatch_async函数的效果")]),t._v(" "),_("p",[_("img",{attrs:{src:"http://xingyajie.oss-cn-hangzhou.aliyuncs.com/uPic/image-20220609100853125.png",alt:"image-20220609100853125"}})]),t._v(" "),_("h2",{attrs:{id:"信号量dispatch-semaphore"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#信号量dispatch-semaphore"}},[t._v("#")]),t._v(" 信号量"),_("strong",[t._v("dispatch_semaphore")])]),t._v(" "),_("p",[t._v("semaphore叫做”信号量”")]),t._v(" "),_("p",[t._v("信号量的初始值，可以用来控制线程并发访问的最大数量")]),t._v(" "),_("p",[t._v("信号量的初始值为1，代表同时只允许1条线程访问资源，保证线程同步")]),t._v(" "),_("p",[_("img",{attrs:{src:"http://xingyajie.oss-cn-hangzhou.aliyuncs.com/uPic/image-20220609101052133.png",alt:"image-20220609101052133"}})]),t._v(" "),_("h2",{attrs:{id:"多线程安全"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#多线程安全"}},[t._v("#")]),t._v(" 多线程安全")]),t._v(" "),_("p",[t._v("1块资源可能会被多个线程共享，也就是"),_("strong",[t._v("多个线程可能会访问同一块资源")]),t._v("，同一个对象、同一个变量、同一个文件")]),t._v(" "),_("p",[t._v("当多个线程访问同一块资源时，很容易引发"),_("strong",[t._v("数据错乱和数据安全")]),t._v("问题")]),t._v(" "),_("p",[t._v("解决方案：使用线程"),_("strong",[t._v("同步技术")]),t._v("，如："),_("strong",[t._v("加锁")])]),t._v(" "),_("h3",{attrs:{id:"osspinlock"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#osspinlock"}},[t._v("#")]),t._v(" OSSpinLock")]),t._v(" "),_("p",[t._v("OSSpinLock叫做”自旋锁”，等待锁的线程会处于"),_("strong",[t._v("忙等")]),t._v("（busy-wait）状态，一直占用着CPU资源")]),t._v(" "),_("p",[t._v("目前已经"),_("strong",[t._v("不再安全")]),t._v("，从iOS10开始不支持，可能会出现"),_("strong",[t._v("优先级反转问题")]),t._v("。如果等待锁的线程优先级较高，它会一直占用着CPU资源，优先级低的线程就无法释放锁")]),t._v(" "),_("p",[t._v("需要导入头文件#import <libkern/OSAtomic.h>")]),t._v(" "),_("div",{staticClass:"language-objective-c extra-class"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[t._v("// 初始化\nOSSpinLock lock = OS_SPINLOCK_INIT;\n// 尝试加锁，需要等待就不加锁，直接返回FALSE，不需要等待就加锁，返回true\nbool res = OSSpinLockTry(&lock);\n// 加锁\nOSSpinLockLock(&lock);\n// 解锁\nOSSpinLockUnlock(&lock);\n")])])]),_("h3",{attrs:{id:"os-unfair-lock"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#os-unfair-lock"}},[t._v("#")]),t._v(" os_unfair_lock")]),t._v(" "),_("p",[t._v("os_unfair_lock用于取代不安全的OSSpinLock ，从iOS10开始才支持")]),t._v(" "),_("p",[t._v("等待os_unfair_lock锁的线程会处于"),_("strong",[t._v("休眠状态")]),t._v("，并非忙等")]),t._v(" "),_("p",[t._v("需要导入头文件#import <os/lock.h>")]),t._v(" "),_("div",{staticClass:"language-objective-c extra-class"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[t._v("// 初始化\nos_unfair_lock lock = OS_UNFAIR_LOCK_INIT;\n// 尝试加锁\nos_unfair_lock_trylock(&lock)\n// 加锁\nos_unfair_lock_lock(&lock);\n// 解锁\nos_unfair_lock_unlock(&lock);\n")])])]),_("h3",{attrs:{id:"pthread-mutex"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#pthread-mutex"}},[t._v("#")]),t._v(" pthread_mutex")]),t._v(" "),_("p",[t._v("mutex叫做”互斥锁”，等待锁的线程会处于"),_("strong",[t._v("休眠状态")])]),t._v(" "),_("p",[t._v("需要导入头文件#import <pthread.h>")]),t._v(" "),_("p",[t._v("pthread_mutex 锁类型")]),t._v(" "),_("ul",[_("li",[t._v("#define PTHREAD_MUTEX_NORMAL\t\t0")]),t._v(" "),_("li",[t._v("#define PTHREAD_MUTEX_ERRORCHECK\t1")]),t._v(" "),_("li",[t._v("#define PTHREAD_MUTEX_RECURSIVE\t\t2    递归锁")]),t._v(" "),_("li",[t._v("#define PTHREAD_MUTEX_DEFAULT\t\tPTHREAD_MUTEX_NORMAL")])]),t._v(" "),_("p",[t._v("普通锁")]),t._v(" "),_("div",{staticClass:"language-objective-c extra-class"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[t._v("// 初始化属性\npthread_mutexattr_t attr;\npthread_mutexattr_init(&attr);\npthread_mutexattr_settype(&attr, PTHREAD_MUTEX_DEFAULT);\n\n// 初始化锁\npthread_mutex_t mutex;\npthread_mutex_init(&mutex, &attr);\n\n// 尝试加锁\npthread_mutex_trylock(&mutex);\n\n// 加锁\npthread_mutex_lock(&mutex);\n    \n// 解锁\npthread_mutex_unlock(&mutex);\n\n// 销毁相关资源\npthread_mutexattr_destroy(&attr);\npthread_mutex_destroy(&mutex);\n\n")])])]),_("p",[t._v("递归锁")]),t._v(" "),_("div",{staticClass:"language-objective-c extra-class"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[t._v("// 初始化属性\npthread_mutexattr_t attr;\npthread_mutexattr_init(&attr);\npthread_mutexattr_settype(&attr, PTHREAD_MUTEX_RECURSIVE);\n\n// 初始化锁\npthread_mutex_t mutex;\npthread_mutex_init(&mutex, &attr);\n")])])]),_("p",[t._v("条件锁。等待进入休眠，放开mutex锁；被唤醒后，会再次对mutex加锁")]),t._v(" "),_("div",{staticClass:"language-objective-c extra-class"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[t._v("// 初始化锁\npthread_mutex_t mutex;\n// NULL代表使用默认属性\npthread_mutex_init(&mutex, NULL);\n\n// 初始化条件\npthread_cond_t cond;\npthread_cond_init(&cond, NULL);\n\n// 等待条件（进入休眠，放开mutex锁；被唤醒后，会再次对mutex加锁）\npthread_cond_wait(&cond, &mutex);\n\n// 激活一个等待该条件的线程\npthread_cond_signal(&cond);\n\n// 激活所有等待该条件的线程\npthread_cond_broadcast(&cond);\n\n// 销毁资源\npthread_mutex_destroy(&mutex);\npthread_cond_destroy(&cond);\n")])])]),_("h3",{attrs:{id:"dispatch-semaphore"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#dispatch-semaphore"}},[t._v("#")]),t._v(" dispatch_semaphore")]),t._v(" "),_("p",[t._v("semaphore叫做”信号量”")]),t._v(" "),_("p",[t._v("信号量的初始值，可以用来控制线程并发访问的最大数量")]),t._v(" "),_("p",[t._v("信号量的初始值为1，代表同时只允许1条线程访问资源，保证线程同步")]),t._v(" "),_("div",{staticClass:"language-objective-c extra-class"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[t._v("int value = 1;\n\ndispatch_semaphore_t semaphore = dispatch_semaphore_create(value);\n\n// 信号量值 <= 0，进入休眠等待，知道信号量 > 0\n// 信号量 > 0, 就 - 1，然后往下执行后面的代码\ndispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);\n\n// 信号量值 + 1\ndispatch_semaphore_signal(semaphore);\n")])])]),_("h3",{attrs:{id:"dispatch-queue-dispatch-queue-serial"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#dispatch-queue-dispatch-queue-serial"}},[t._v("#")]),t._v(" dispatch_queue(DISPATCH_QUEUE_SERIAL)")]),t._v(" "),_("p",[t._v("GCD串行队列")]),t._v(" "),_("div",{staticClass:"language-objective-c extra-class"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[t._v('dispatch_queue_t queue = dispatch_queue_create("lock", DISPATCH_QUEUE_SERIAL);\ndispatch_sync(queue, ^{\n\n});\n')])])]),_("h3",{attrs:{id:"nslock"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#nslock"}},[t._v("#")]),t._v(" NSLock")]),t._v(" "),_("p",[t._v("NSLock是对mutex普通锁的封装，面向对象")]),t._v(" "),_("div",{staticClass:"language-objective-c extra-class"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[t._v("@protocol NSLocking\n\n- (void)lock;\n- (void)unlock;\n\n@end\n\n@interface NSLock : NSObject <NSLocking> {\n@private\n    void *_priv;\n}\n\n- (BOOL)tryLock;\n- (BOOL)lockBeforeDate:(NSDate *)limit;\n\n@property (nullable, copy) NSString *name API_AVAILABLE(macos(10.5), ios(2.0), watchos(2.0), tvos(9.0));\n\n@end\n")])])]),_("h3",{attrs:{id:"nsrecursivelock"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#nsrecursivelock"}},[t._v("#")]),t._v(" NSRecursiveLock")]),t._v(" "),_("p",[t._v("NSRecursiveLock是对mutex递归锁的封装，API与NSLock基本一致")]),t._v(" "),_("h3",{attrs:{id:"nscondition"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#nscondition"}},[t._v("#")]),t._v(" NSCondition")]),t._v(" "),_("p",[t._v("NSCondition 是对 mutex条件锁的封装")]),t._v(" "),_("div",{staticClass:"language-objective-c extra-class"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[t._v("@interface NSCondition : NSObject <NSLocking> {\n@private\n    void *_priv;\n}\n\n- (void)wait;\n- (BOOL)waitUntilDate:(NSDate *)limit;\n- (void)signal;\n- (void)broadcast;\n\n@property (nullable, copy) NSString *name API_AVAILABLE(macos(10.5), ios(2.0), watchos(2.0), tvos(9.0));\n\n@end\n")])])]),_("h3",{attrs:{id:"nsconditionlock"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#nsconditionlock"}},[t._v("#")]),t._v(" NSConditionLock")]),t._v(" "),_("p",[t._v("NSConditionLock是对NSCondition的进一步封装，可以设置具体的条件值")]),t._v(" "),_("div",{staticClass:"language-objective-c extra-class"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[t._v("@interface NSConditionLock : NSObject <NSLocking> {\n@private\n    void *_priv;\n}\n\n- (instancetype)initWithCondition:(NSInteger)condition NS_DESIGNATED_INITIALIZER;\n\n@property (readonly) NSInteger condition;\n- (void)lockWhenCondition:(NSInteger)condition;\n- (BOOL)tryLock;\n- (BOOL)tryLockWhenCondition:(NSInteger)condition;\n- (void)unlockWithCondition:(NSInteger)condition;\n- (BOOL)lockBeforeDate:(NSDate *)limit;\n- (BOOL)lockWhenCondition:(NSInteger)condition beforeDate:(NSDate *)limit;\n\n@property (nullable, copy) NSString *name API_AVAILABLE(macos(10.5), ios(2.0), watchos(2.0), tvos(9.0));\n\n@end\n")])])]),_("h3",{attrs:{id:"synchronized"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#synchronized"}},[t._v("#")]),t._v(" @synchronized")]),t._v(" "),_("p",[t._v("@synchronized是对mutex递归锁的封装")]),t._v(" "),_("p",[t._v("@synchronized(obj)内部会生成obj对应的递归锁，然后进行加锁、解锁操作")]),t._v(" "),_("div",{staticClass:"language-objective-c extra-class"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[t._v("@synchronized(obj) { // objc_sync_enter\n\t\t\n}\n")])])]),_("h2",{attrs:{id:"线程同步方案对比"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#线程同步方案对比"}},[t._v("#")]),t._v(" 线程同步方案对比")]),t._v(" "),_("p",[_("strong",[t._v("性能")]),t._v("方面，性能从高到低排序")]),t._v(" "),_("ul",[_("li",[t._v("os_unfair_lock")]),t._v(" "),_("li",[t._v("OSSpinLock")]),t._v(" "),_("li",[t._v("dispatch_semaphore")]),t._v(" "),_("li",[t._v("pthread_mutex")]),t._v(" "),_("li",[t._v("dispatch_queue(DISPATCH_QUEUE_SERIAL)")]),t._v(" "),_("li",[t._v("NSLock")]),t._v(" "),_("li",[t._v("NSCondition")]),t._v(" "),_("li",[t._v("pthread_mutex(recursive)")]),t._v(" "),_("li",[t._v("NSRecursiveLock")]),t._v(" "),_("li",[t._v("NSConditionLock")]),t._v(" "),_("li",[t._v("@synchronized")])]),t._v(" "),_("p",[_("strong",[t._v("如何选择？")])]),t._v(" "),_("p",[t._v("开发方便考虑 GCD信号量，串行线程。")]),t._v(" "),_("p",[t._v("面向对象考虑 NSLock，NSRecursiveLock，NSCondition，NSConditionLock")]),t._v(" "),_("p",[t._v("追求性能考虑 os_unfair_lock")]),t._v(" "),_("p",[t._v("代码简单考虑 @synchronized")]),t._v(" "),_("h2",{attrs:{id:"自旋锁互斥锁对比"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#自旋锁互斥锁对比"}},[t._v("#")]),t._v(" 自旋锁互斥锁对比")]),t._v(" "),_("p",[t._v("什么情况使用自旋锁比较划算？")]),t._v(" "),_("ul",[_("li",[t._v("预计线程等待锁的时间很短")]),t._v(" "),_("li",[t._v("加锁的代码（临界区）经常被调用，但竞争情况很少发生")]),t._v(" "),_("li",[t._v("CPU资源不紧张")]),t._v(" "),_("li",[t._v("多核处理器")])]),t._v(" "),_("p",[t._v("什么情况使用互斥锁比较划算？")]),t._v(" "),_("ul",[_("li",[t._v("预计线程等待锁的时间较长")]),t._v(" "),_("li",[t._v("单核处理器")]),t._v(" "),_("li",[t._v("临界区有IO操作")]),t._v(" "),_("li",[t._v("临界区代码复杂或者循环量大")]),t._v(" "),_("li",[t._v("临界区竞争非常激烈")])]),t._v(" "),_("h2",{attrs:{id:"atomic"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#atomic"}},[t._v("#")]),t._v(" atomic")]),t._v(" "),_("p",[t._v("atomic用于保证属性setter、getter的原子性操作，相当于在getter和setter内部加了线程同步的锁")]),t._v(" "),_("p",[t._v("可以参考源码objc4的objc-accessors.mm")]),t._v(" "),_("p",[t._v("它并不能保证使用属性的过程是线程安全的")]),t._v(" "),_("h2",{attrs:{id:"ios读写安全方案"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#ios读写安全方案"}},[t._v("#")]),t._v(" iOS读写安全方案")]),t._v(" "),_("p",[t._v("读写安全，需要多读单写。常见的方案有：")]),t._v(" "),_("ul",[_("li",[t._v("pthread_rwlock：读写锁")]),t._v(" "),_("li",[t._v("dispatch_barrier_async：异步栅栏调用")])]),t._v(" "),_("h3",{attrs:{id:"pthread-rwlock"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#pthread-rwlock"}},[t._v("#")]),t._v(" pthread_rwlock")]),t._v(" "),_("p",[t._v("等待的线程会进入休眠")]),t._v(" "),_("div",{staticClass:"language-objective-c extra-class"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[t._v("pthread_rwlock_t lock;\n// 初始化锁\npthread_rwlock_init(&lock, NULL);\n\n// 读 加锁\npthread_rwlock_rdlock(&lock);\n\n// 读 尝试加锁\npthread_rwlock_tryrdlock(&lock);\n\n// 写 加锁\npthread_rwlock_wrlock(&lock);\n\n// 写 尝试加锁\npthread_rwlock_trywrlock(&lock);\n\n// 解锁\npthread_rwlock_unlock(&lock);\n\n// 销毁\npthread_rwlock_destroy(&_lock);\n\n")])])]),_("h3",{attrs:{id:"dispatch-barrier-async"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#dispatch-barrier-async"}},[t._v("#")]),t._v(" dispatch_barrier_async")]),t._v(" "),_("p",[t._v("这个函数传入的并发队列必须是自己通过dispatch_queue_cretate创建的")]),t._v(" "),_("p",[t._v("如果传入的是一个串行或是一个全局的并发队列，那这个函数便等同于dispatch_async函数的效果")]),t._v(" "),_("div",{staticClass:"language-objective-c extra-class"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[t._v('dispatch_queue_t queue = dispatch_queue_create("rw_queue", DISPATCH_QUEUE_CONCURRENT);\n\n// 读\ndispatch_async(queue, ^{\n   \n});\n        \n// 写\ndispatch_barrier_async(queue, ^{\n\n});\n')])])])])}),[],!1,null,null,null);_.default=r.exports}}]);