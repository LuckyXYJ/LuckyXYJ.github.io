(window.webpackJsonp=window.webpackJsonp||[]).push([[75],{376:function(e,l,t){"use strict";t.r(l);var a=t(6),o=Object(a.a)({},(function(){var e=this,l=e._self._c;return l("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[l("h2",{attrs:{id:"module-模块"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#module-模块"}},[e._v("#")]),e._v(" Module(模块)")]),e._v(" "),l("p",[e._v("Module(模块)-最小的代码单元。一个Module是机器代码和数据的最小单位，可以独立于其他代码单位进行链接。通常，Module是通过编译单个源文件生成的目标文件。")]),e._v(" "),l("p",[e._v("在静态链接的时候，也就是静态库链接到主项目或者动态库时，最后生成可执行文件或者动态库时。静态链接器可以把多个Module链接优化成一个，来减少本来多个Module直接调用的问题。")]),e._v(" "),l("p",[e._v("module.modulemap 用来描述头文件与module之间映射的关系")]),e._v(" "),l("p",[e._v("module生成命令")]),e._v(" "),l("div",{staticClass:"language- extra-class"},[l("pre",{pre:!0,attrs:{class:"language-text"}},[l("code",[e._v("# -fmodules：允许使用module语言来表示头文件\n# -fmodule-map-file：module map的路径。如不指明默认module.modulemap\n# -fmodules-cache-path：编译后的module缓存路径\nclang  -fmodules -fmodule-map-file=Cat.modulemap -fmodules-cache-path=../prebuilt -c use.c -o use.o\n")])])]),l("h2",{attrs:{id:"module-modulemap文件"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#module-modulemap文件"}},[e._v("#")]),e._v(" module.modulemap文件")]),e._v(" "),l("div",{staticClass:"language- extra-class"},[l("pre",{pre:!0,attrs:{class:"language-text"}},[l("code",[e._v('module Charts {\n  umbrella header "Charts-umbrella.h"\n\n  export *\n  module * { export * }\n}\n')])])]),l("ul",[l("li",[e._v("module:定义一个module")]),e._v(" "),l("li",[e._v("export：导出当前代表的头文件使用的头文件")]),e._v(" "),l("li",[e._v("export * ：匹配目录下所有的头文件")]),e._v(" "),l("li",[e._v("module * ：目录下所有的头文件都当作一个子module")]),e._v(" "),l("li",[e._v("explicit : 显式声明一个module的名称")])]),e._v(" "),l("h2",{attrs:{id:"swift库使用oc代码"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#swift库使用oc代码"}},[e._v("#")]),e._v(" swift库使用OC代码")]),e._v(" "),l("p",[e._v("在项目中swift使用OC代码通过桥联文件即可，但是在swift中却无法使用桥联文件")]),e._v(" "),l("p",[e._v("解决方案：")]),e._v(" "),l("ol",[l("li",[e._v("oc的头文件放到modulemap下")]),e._v(" "),l("li",[e._v("oc的头文件放到私有的modulemap下")]),e._v(" "),l("li",[e._v("协议的方式 投机取巧")])]),e._v(" "),l("h2",{attrs:{id:"swift静态库的合并"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#swift静态库的合并"}},[e._v("#")]),e._v(" Swift静态库的合并")]),e._v(" "),l("p",[e._v("难点：.swiftmodule 文件（Swift的头文件）")]),e._v(" "),l("ol",[l("li",[e._v("libtool 合并静态库本身")]),e._v(" "),l("li",[e._v("用到的头文件和Swift头文件和modulemap文件通过目录的形式放到一起、")]),e._v(" "),l("li",[e._v("OC要用合并的静态库：clang: other c flags ：-fmodule-map-file "),l("modulemap",{attrs:{path:""}})],1),e._v(" "),l("li",[e._v("Swift要用合并的静态库 : SwiftC :other swift flags 显式告诉SwiftC "),l("modulemap",{attrs:{dir:""}})],1)]),e._v(" "),l("h2",{attrs:{id:"oc映射到swift方式"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#oc映射到swift方式"}},[e._v("#")]),e._v(" OC映射到Swift方式")]),e._v(" "),l("ol",[l("li",[e._v("宏")]),e._v(" "),l("li",[e._v("<工程名称>.")]),e._v(" "),l("li",[e._v("文件")])])])}),[],!1,null,null,null);l.default=o.exports}}]);