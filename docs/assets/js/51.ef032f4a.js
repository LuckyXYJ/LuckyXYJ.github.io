(window.webpackJsonp=window.webpackJsonp||[]).push([[51],{365:function(e,t,a){"use strict";a.r(t);var r=a(6),v=Object(r.a)({},(function(){var e=this,t=e._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h2",{attrs:{id:"metal"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#metal"}},[e._v("#")]),e._v(" Metal")]),e._v(" "),t("p",[e._v("Metal 是苹果在2018年推出的图形编程接口，通过Metal相关API可以直接操作GPU，能最大限度的利用GPU能力。")]),e._v(" "),t("p",[e._v("UIKit --\x3e Core Animation --\x3e Metal --\x3e GPU Drivel --\x3e GPU")]),e._v(" "),t("p",[e._v("Metal 特点：")]),e._v(" "),t("ul",[t("li",[e._v("低CPU开销")]),e._v(" "),t("li",[e._v("最佳GPU性能，即metal 能在GPU上发挥最大的性能")]),e._v(" "),t("li",[e._v("最大限度的提高CPU/GPU 的并发性")]),e._v(" "),t("li",[e._v("有效的资源管理")])]),e._v(" "),t("p",[e._v("Metal 图形管道")]),e._v(" "),t("p",[e._v("​"),t("img",{attrs:{src:"http://xingyajie.oss-cn-hangzhou.aliyuncs.com/uPic/1188.png",alt:"img"}}),e._v("​")]),e._v(" "),t("h2",{attrs:{id:"metal-使用建议"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#metal-使用建议"}},[e._v("#")]),e._v(" Metal 使用建议")]),e._v(" "),t("ul",[t("li",[t("strong",[e._v("Separate Your Rendering Loop")]),e._v(" 分开渲染循环：不希望将渲染的处理放到VC中，希望将渲染循环封装在一个单独的类中")]),e._v(" "),t("li",[t("strong",[e._v("Respond to View Events")]),e._v(" 响应视图的事件，即MTKViewDelegate协议，也需要放在自定义的渲染循环中")]),e._v(" "),t("li",[t("strong",[e._v("Metal Command Objects")]),e._v(" 创建一个命令对象，即创建执行命令的GPU设备、MTLCommandQueue命令队列以及驱动GPU的MTCommandBuffer渲染缓存区")])]),e._v(" "),t("h2",{attrs:{id:"metal命令对象之间的关系"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#metal命令对象之间的关系"}},[e._v("#")]),e._v(" Metal命令对象之间的关系")]),e._v(" "),t("ul",[t("li",[e._v("命令缓存区（command buffer）是从命令队列（command queue）创建的")]),e._v(" "),t("li",[e._v("命令编码器（command encoder）将命令编码到命令缓存区中")]),e._v(" "),t("li",[e._v("提交命令缓存区并将其发送到GPU")]),e._v(" "),t("li",[e._v("GPU执行命令并将结果呈现为可绘制")])]),e._v(" "),t("p",[e._v("​"),t("img",{attrs:{src:"http://xingyajie.oss-cn-hangzhou.aliyuncs.com/uPic/1200.png",alt:"img"}}),e._v("​")]),e._v(" "),t("h2",{attrs:{id:"metal-kit"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#metal-kit"}},[e._v("#")]),e._v(" Metal Kit")]),e._v(" "),t("p",[e._v("Metal Kit 是基于Metal封装的框架， 方便我们用极少的代码完成 metal 需求")]),e._v(" "),t("h3",{attrs:{id:"mtkview"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#mtkview"}},[e._v("#")]),e._v(" MTKView")]),e._v(" "),t("p",[e._v("在MetalKit中提供了一个视图类"),t("strong",[e._v("MTKView")]),e._v("，类似于GLKit中GLKView，它是NSView（macOS中的视图类）或者UIView（iOS、tvOS中的视图类）的子类。用于处理metal绘制并显示到屏幕过程中的细节。")]),e._v(" "),t("h3",{attrs:{id:"mtldevice"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#mtldevice"}},[e._v("#")]),e._v(" MTLDevice")]),e._v(" "),t("p",[e._v("由于metal是操作GPU的，所以需要获取GPU使用权限，即拿到GPU对象，Metal中提供了MTLDevice协议表示GPU接口，在iOS中一般是通过默认的方式MTLCreateSystemDefaultDevice()获取GPU")]),e._v(" "),t("div",{staticClass:"language-objectivec extra-class"},[t("pre",{pre:!0,attrs:{class:"language-objectivec"}},[t("code",[e._v("_view"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),e._v("device "),t("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" "),t("span",{pre:!0,attrs:{class:"token function"}},[e._v("MTLCreateSystemDefaultDevice")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n")])])]),t("ul",[t("li",[e._v("metal的使用必须使用真机，且必须是6s及以上的机型")]),e._v(" "),t("li",[e._v("如果设备不支持mental，将会返回空")]),e._v(" "),t("li",[e._v("如果想使用多个MTLDevice实例，或者从一个MTLDevice切换到另一个，则需要为每个MTLDevice创建单独的一组对象")])]),e._v(" "),t("p",[e._v("MTLDevice协议表示可以执行命令的GPU，提供了如下功能")]),e._v(" "),t("ul",[t("li",[e._v("创建新的命令队列")]),e._v(" "),t("li",[e._v("从内存分配缓冲区")]),e._v(" "),t("li",[e._v("创建纹理")]),e._v(" "),t("li",[e._v("查询设备功能")])]),e._v(" "),t("h3",{attrs:{id:"mtlcommandqueue"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#mtlcommandqueue"}},[e._v("#")]),e._v(" MTLCommandQueue")]),e._v(" "),t("p",[e._v("在获取了GPU后，还需要一个渲染队列，即"),t("a",{attrs:{href:"https://links.jianshu.com/go?to=https%3A%2F%2Fdeveloper.apple.com%2Flibrary%2Farchive%2Fdocumentation%2FMiscellaneous%2FConceptual%2FMetalProgrammingGuide%2FCmd-Submiss%2FCmd-Submiss.html%23%2F%2Fapple_ref%2Fdoc%2Fuid%2FTP40014221-CH3-SW14",target:"_blank",rel:"noopener noreferrer"}},[e._v("命令队列Command Queue"),t("OutboundLink")],1),e._v("，类型是MTLCommandQueue，该队列是与GPU交互的第一个对象，队列中存储的是将要渲染的命令MTLCommandBuffer。")]),e._v(" "),t("p",[e._v("队列的获取需要通过"),t("strong",[e._v("MTLDevice")]),e._v("对象获取，且每个命令队列的生命周期很长，因此commandQueue可以重复使用，而不是频繁创建和销毁。")]),e._v(" "),t("div",{staticClass:"language-undefined extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("_commandQueue = [_device newCommandQueue];\n")])])]),t("p",[e._v("在绘制之前，首先需要配置好MTKView、MTLDevice以及MTLCommandQueue后，其次是准备渲染到屏幕上的数据，即准备缓存数据MTLCommandBuffer，例如顶点数据等。")]),e._v(" "),t("p",[e._v("简单的渲染流程就是")]),e._v(" "),t("ul",[t("li",[e._v("先通过MTLCommandBuffer创建渲染缓存区，")]),e._v(" "),t("li",[e._v("其次通过MTLRenderPassDescriptor创建渲染描述符，")]),e._v(" "),t("li",[e._v("然后再通过创建的渲染缓存区和渲染描述符创建命令编辑器MTLRenderCommandEncoder进行编码")]),e._v(" "),t("li",[e._v("最后是结束编码，提交渲染命令，在完成渲染后，将命令缓存区提交至GPU")])]),e._v(" "),t("h3",{attrs:{id:"mtlcommandbuffer"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#mtlcommandbuffer"}},[e._v("#")]),e._v(" MTLCommandBuffer")]),e._v(" "),t("p",[t("a",{attrs:{href:"https://links.jianshu.com/go?to=https%3A%2F%2Fdeveloper.apple.com%2Flibrary%2Farchive%2Fdocumentation%2FMiscellaneous%2FConceptual%2FMetalProgrammingGuide%2FCmd-Submiss%2FCmd-Submiss.html%23%2F%2Fapple_ref%2Fdoc%2Fuid%2FTP40014221-CH3-SW15",target:"_blank",rel:"noopener noreferrer"}},[e._v("命令缓存区 Command Buffer"),t("OutboundLink")],1),e._v("主要是用于存储编码的命令，其生命周期是知道缓存区被提交到GPU执行为止，单个的命令缓存区可以包含不同的编码命令，主要取决于用于构建它的编码器的类型和数量。")]),e._v(" "),t("p",[e._v("命令缓存区的创建可以通过调用"),t("code",[e._v("MTLCommandQueue")]),e._v("​的"),t("code",[e._v("commandBuffer")]),e._v("​方法。且command buffer对象的提交只能提交至创建它的"),t("code",[e._v("MTLCommandQueue")]),e._v("​对象中")]),e._v(" "),t("p",[e._v("commandBuffer在未提交命令缓存区之前，是不会开始执行的，提交后，命令缓存区将按其入队的顺序执行，commandBuffer的提交方式有以下两种，不同的提交方式表示不同的执行顺醋")]),e._v(" "),t("ul",[t("li",[e._v("​"),t("code",[e._v("enqueue")]),e._v("​：顺序执行，enqueue方法在命令队列中为命令缓存区保留一个位置，此时并未提交命令缓存区，当最终提交命令缓存区后，按照命令队列的顺序依次执行")]),e._v(" "),t("li",[e._v("​"),t("code",[e._v("commit")]),e._v("​：插队尽快执行，如果前面有commit还是需要排队等着")])]),e._v(" "),t("h3",{attrs:{id:"mtlrendercommandencoder"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#mtlrendercommandencoder"}},[e._v("#")]),e._v(" MTLRenderCommandEncoder")]),e._v(" "),t("p",[t("a",{attrs:{href:"https://links.jianshu.com/go?to=https%3A%2F%2Fdeveloper.apple.com%2Flibrary%2Farchive%2Fdocumentation%2FMiscellaneous%2FConceptual%2FMetalProgrammingGuide%2FCmd-Submiss%2FCmd-Submiss.html%23%2F%2Fapple_ref%2Fdoc%2Fuid%2FTP40014221-CH3-SW14",target:"_blank",rel:"noopener noreferrer"}},[e._v("MTLRenderCommandEncoder"),t("OutboundLink")],1),e._v("表示单个渲染过程中相关联的渲染状态和渲染命令，有以下功能：")]),e._v(" "),t("ul",[t("li",[e._v("指定图形资源，例如缓存区和纹理对象，其中包含顶点、片元、纹理图片数据")]),e._v(" "),t("li",[e._v("指定一个MTLRenderPipelineState对象，表示编译的渲染状态，包含顶点着色器和片元着色器的编译&链接情况")]),e._v(" "),t("li",[e._v("指定固定功能，包括视口、三角形填充模式、剪刀矩形、深度、模板测试以及其他值")]),e._v(" "),t("li",[e._v("绘制3D图元")])]),e._v(" "),t("p",[e._v("其中在创建commandEncoder之前，需要县创建渲染描述符"),t("code",[e._v("MTLRenderPassDescriptor")]),e._v("​，渲染描述符通过"),t("code",[e._v("MTKView")]),e._v("​的"),t("code",[e._v("currentRenderPassDescriptor")]),e._v("​获取")]),e._v(" "),t("div",{staticClass:"language-objectivec extra-class"},[t("pre",{pre:!0,attrs:{class:"language-objectivec"}},[t("code",[e._v("MTLRenderPassDescriptor "),t("span",{pre:!0,attrs:{class:"token operator"}},[e._v("*")]),e._v("renderPassDescriptor "),t("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" view"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),e._v("currentRenderPassDescriptor"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n")])])]),t("p",[e._v("然后通过commandBuffer结合渲染描述符创建命令编辑器")]),e._v(" "),t("div",{staticClass:"language-objectivec extra-class"},[t("pre",{pre:!0,attrs:{class:"language-objectivec"}},[t("code",[e._v("id"),t("span",{pre:!0,attrs:{class:"token operator"}},[e._v("<")]),e._v("MTLRenderCommandEncoder"),t("span",{pre:!0,attrs:{class:"token operator"}},[e._v(">")]),e._v(" renderEncoder "),t("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("[")]),e._v("commandBuffer renderCommandEncoderWithDescriptor"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(":")]),e._v("renderPassDescriptor"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("]")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n")])])]),t("p",[e._v("使用渲染命令编码器执行渲染的过程")]),e._v(" "),t("ul",[t("li",[e._v("过调用"),t("code",[e._v("MTLCommandBuffer")]),e._v("​对象的"),t("code",[e._v("makeRenderCommandEncoder（descriptor :)")]),e._v("​方法来创建"),t("code",[e._v("MTLRenderCommandEncoder")]),e._v("​对象。")]),e._v(" "),t("li",[e._v("调用"),t("code",[e._v("setRenderPipelineState（_ :)")]),e._v("​方法以指定"),t("code",[e._v("MTLRenderPipelineState")]),e._v("​，该状态定义图形渲染管道的状态，包括顶点和片段函数。")]),e._v(" "),t("li",[e._v("指定用于顶点和片元函数输入和输出的资源，并在对应的参数中设置每个资源的位置（即索引），即将顶点数据等通过commandEncoder调用"),t("code",[e._v("setVertexBytes:length:atIndex:")]),e._v("​函数传递到metal文件的顶点着色器和片元着色器函数")]),e._v(" "),t("li",[e._v("指定其他的固定功能状态，例如通过commandEncoder调用"),t("code",[e._v("setViewport:")]),e._v("​函数设置视口大小等")]),e._v(" "),t("li",[e._v("绘制图形")]),e._v(" "),t("li",[e._v("调用"),t("code",[e._v("endEncoding（）")]),e._v("​方法以终止渲染命令编码器。")])]),e._v(" "),t("h2",{attrs:{id:"metal-支持的采样器状态和默认值"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#metal-支持的采样器状态和默认值"}},[e._v("#")]),e._v(" Metal 支持的采样器状态和默认值")]),e._v(" "),t("p",[e._v("​"),t("img",{attrs:{src:"http://xingyajie.oss-cn-hangzhou.aliyuncs.com/uPic/image-20220819163141761.png",alt:"采样器状态和默认值"}}),e._v("​")])])}),[],!1,null,null,null);t.default=v.exports}}]);