(window.webpackJsonp=window.webpackJsonp||[]).push([[57],{361:function(_,v,e){"use strict";e.r(v);var t=e(6),r=Object(t.a)({},(function(){var _=this,v=_._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[v("h2",{attrs:{id:"dns-域名解析过程"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#dns-域名解析过程"}},[_._v("#")]),_._v(" DNS 域名解析过程")]),_._v(" "),v("p",[_._v("DNS 客户端进行域名 "),v("a",{attrs:{href:"http://www.tsinghua.edu.cn",target:"_blank",rel:"noopener noreferrer"}},[_._v("www.tsinghua.edu.cn"),v("OutboundLink")],1),_._v(" 的解析过程如下：")]),_._v(" "),v("ol",[v("li",[v("strong",[_._v("DNS 客户端")]),_._v("向本地域名服务器发送请求，查询 "),v("a",{attrs:{href:"http://www.tsinghua.edu.cn",target:"_blank",rel:"noopener noreferrer"}},[_._v("www.tsinghua.edu.cn"),v("OutboundLink")],1),_._v(" 主机的 IP 地址；")]),_._v(" "),v("li",[v("strong",[_._v("本地域名服务器")]),_._v("查询数据库，发现没有域名为 "),v("a",{attrs:{href:"http://www.tsinghua.edu.cn",target:"_blank",rel:"noopener noreferrer"}},[_._v("www.tsinghua.edu.cn"),v("OutboundLink")],1),_._v(" 的主机，于是将请求发送给根域名服务器；")]),_._v(" "),v("li",[v("strong",[_._v("根域名服务器")]),_._v("查询数据库，发现没有这个主机域名记录，但是根域名服务器知道 cn 域名服务器可以解析这个域名，于是将 cn 域名服务器的 IP 地址返回给本地域名服务器；")]),_._v(" "),v("li",[v("strong",[_._v("本地域名服务器")]),_._v("向 cn 域名服务器查询 "),v("a",{attrs:{href:"http://www.tsinghua.edu.cn",target:"_blank",rel:"noopener noreferrer"}},[_._v("www.tsinghua.edu.cn"),v("OutboundLink")],1),_._v(" 主机的 IP 地址；")]),_._v(" "),v("li",[v("strong",[_._v("cn 域名服务器")]),_._v("查询数据库，也没有相关记录，但是知道 edu.cn 域名服务器可以解析这个域名，于是将 edu.cn 域名服务器的 IP 地址返回给本地域名服务器；")]),_._v(" "),v("li",[v("strong",[_._v("本地域名服务器")]),_._v("再向 edu.cn 域名服务器查询 "),v("a",{attrs:{href:"http://www.tsinghua.edu.cn",target:"_blank",rel:"noopener noreferrer"}},[_._v("www.tsinghua.edu.cn"),v("OutboundLink")],1),_._v(" 主机 IP 地址；")]),_._v(" "),v("li",[v("strong",[_._v("edu.cn 域名服务器")]),_._v("查询数据库，也没有相关记录，但是知道 tsinghua.edu.cn 域名服务器可以解析这个域名，于是将 tsinghua.edu.cn 的域名服务器 IP 地址返回给本地域名服务器；")]),_._v(" "),v("li",[v("strong",[_._v("本地域名服务器")]),_._v("向 tsinghua.edu.cn 域名服务器查询 "),v("a",{attrs:{href:"http://www.tsinghua.edu.cn",target:"_blank",rel:"noopener noreferrer"}},[_._v("www.tsinghua.edu.cn"),v("OutboundLink")],1),_._v(" 主机的 IP 地址；")]),_._v(" "),v("li",[v("strong",[_._v("tsinghua.edu.cn 域名服务器")]),_._v("查询数据库，发现有主机域名记录，于是给本地域名服务器返回 "),v("a",{attrs:{href:"http://www.tsinghua.edu.cn",target:"_blank",rel:"noopener noreferrer"}},[_._v("www.tsinghua.edu.cn"),v("OutboundLink")],1),_._v(" 对应的 IP 地址；")]),_._v(" "),v("li",[_._v("最后"),v("strong",[_._v("本地域名服务器")]),_._v("将 "),v("a",{attrs:{href:"http://www.tsinghua.edu.cn",target:"_blank",rel:"noopener noreferrer"}},[_._v("www.tsinghua.edu.cn"),v("OutboundLink")],1),_._v(" 的 IP 地址返回给客户端，整个解析过程完成。")])]),_._v(" "),v("h2",{attrs:{id:"tcp建立连接三次握手"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#tcp建立连接三次握手"}},[_._v("#")]),_._v(" TCP建立连接三次握手")]),_._v(" "),v("h3",{attrs:{id:"三次握手的过程-需要说明状态转换"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#三次握手的过程-需要说明状态转换"}},[_._v("#")]),_._v(" 三次握手的过程，需要说明状态转换")]),_._v(" "),v("ul",[v("li",[_._v("第一次握手：客户端发送 "),v("code",[_._v("SYN")]),_._v(" 报文，并进入 "),v("code",[_._v("SYN_SENT")]),_._v(" 状态，等待服务器的确认；")]),_._v(" "),v("li",[_._v("第二次握手：服务器收到 "),v("code",[_._v("SYN")]),_._v(" 报文，需要给客户端发送 "),v("code",[_._v("ACK")]),_._v(" 确认报文，同时服务器也要向客户端发送一个 "),v("code",[_._v("SYN")]),_._v(" 报文，所以也就是向客户端发送 "),v("code",[_._v("SYN + ACK")]),_._v(" 报文，此时服务器进入 "),v("code",[_._v("SYN_RCVD")]),_._v("状态；")]),_._v(" "),v("li",[_._v("第三次握手：客户端收到 "),v("code",[_._v("SYN + ACK")]),_._v(" 报文，向服务器发送确认包，客户端进入 "),v("code",[_._v("ESTABLISHED")]),_._v(" 状态。待服务器收到客户端发送的 "),v("code",[_._v("ACK")]),_._v(" 包也会进入 "),v("code",[_._v("ESTABLISHED")]),_._v(" 状态，完成三次握手。")])]),_._v(" "),v("h3",{attrs:{id:"为什么要三次握手-两次是否可以"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#为什么要三次握手-两次是否可以"}},[_._v("#")]),_._v(" 为什么要三次握手，两次是否可以")]),_._v(" "),v("ul",[v("li",[_._v("（一）确认双方的收发能力")])]),_._v(" "),v("blockquote",[v("p",[_._v("TCP 建立连接之前，需要确认客户端与服务器双方的收包和发包的能力。")]),_._v(" "),v("p",[v("em",[_._v("1.")]),_._v(" 第一次握手：客户端发送网络包，服务端收到了。这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的。")]),_._v(" "),v("p",[v("em",[_._v("2.")]),_._v(" 第二次握手：服务端发包，客户端收到了。这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。不过此时服务器并不能确认客户端的接收能力是否正常。")]),_._v(" "),v("p",[v("em",[_._v("3.")]),_._v(" 第三次握手：客户端发包，服务端收到了。这样服务端就能得出结论：客户端的接收、发送能力正常，服务器自己的发送、接收能力也正常。")]),_._v(" "),v("p",[_._v("所以，只有三次握手才能确认双方的接收与发送能力是否正常。")])]),_._v(" "),v("ul",[v("li",[_._v("（二）序列号可靠同步")])]),_._v(" "),v("blockquote",[v("p",[_._v("如果是两次握手，服务端无法确定客户端是否已经接收到了自己发送的初始序列号，如果第二次握手报文丢失，那么客户端就无法知道服务端的初始序列号，那 TCP 的可靠性就无从谈起。")])]),_._v(" "),v("ul",[v("li",[_._v("（三）阻止重复历史连接的初始化")])]),_._v(" "),v("blockquote",[v("p",[_._v("客户端由于某种原因发送了两个不同序号的 "),v("code",[_._v("SYN")]),_._v(" 包，我们知道网络环境是复杂的，旧的数据包有可能先到达服务器。如果是两次握手，服务器收到旧的 "),v("code",[_._v("SYN")]),_._v(" 就会立刻建立连接，那么会造成网络异常。")]),_._v(" "),v("p",[_._v("如果是三次握手，服务器需要回复 "),v("code",[_._v("SYN+ACK")]),_._v(" 包，客户端会对比应答的序号，如果发现是旧的报文，就会给服务器发 "),v("code",[_._v("RST")]),_._v(" 报文，直到正常的 "),v("code",[_._v("SYN")]),_._v(" 到达服务器后才正常建立连接。")]),_._v(" "),v("p",[_._v("所以三次握手才有足够的上下文信息来判断当前连接是否是历史连接。")])]),_._v(" "),v("ul",[v("li",[_._v("（四）安全问题")])]),_._v(" "),v("blockquote",[v("p",[_._v("我们知道 TCP 新建连接时，内核会为连接分配一系列的内存资源，如果采用两次握手，就建立连接，那会放大 DDOS 攻击的。")]),_._v(" "),v("p",[_._v("TCP 作为一种可靠传输控制协议，其核心思想：既要保证数据可靠传输，又要提高传输的效率，而三次握手恰好可以满足以上两方面的需求！")])]),_._v(" "),v("h3",{attrs:{id:"初始序列号-isn"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#初始序列号-isn"}},[_._v("#")]),_._v(" 初始序列号（ISN）")]),_._v(" "),v("p",[v("strong",[_._v("ISN 是什么？")])]),_._v(" "),v("p",[_._v("答："),v("code",[_._v("ISN")]),_._v(" 全称是 "),v("code",[_._v("Initial Sequence Number")]),_._v("，是 TCP 发送方的字节数据编号的原点，告诉对方我要开始发送数据的初始化序列号")]),_._v(" "),v("p",[v("strong",[_._v("ISN 是固定不变的吗？")])]),_._v(" "),v("p",[_._v("答：ISN 如果是固定的，攻击者很容易猜出后续的确认序号，为了安全起见，避免被第三方猜到从而发送伪造的 "),v("code",[_._v("RST")]),_._v(" 报文，因此 ISN 是动态生成的连接队列")]),_._v(" "),v("h3",{attrs:{id:"半连接队列"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#半连接队列"}},[_._v("#")]),_._v(" 半连接队列？")]),_._v(" "),v("p",[v("strong",[_._v("什么是半连接队列")]),_._v("？")]),_._v(" "),v("p",[_._v("答：服务器第一次收到客户端的 "),v("code",[_._v("SYN")]),_._v(" 之后，就会处于 "),v("code",[_._v("SYN_RCVD")]),_._v("状态，此时双方还没有完全建立连接。服务器会把这种状态下请求连接放在一个队列里，我们把这种队列称之为半连接队列。")]),_._v(" "),v("p",[_._v("当然还有一个"),v("em",[_._v("全连接队列")]),_._v("，就是已经完成三次握手，建立起连接的就会放在全连接队列中。如果队列满了就有可能会出现丢包现象。")]),_._v(" "),v("h3",{attrs:{id:"三次握手可以携带数据吗"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#三次握手可以携带数据吗"}},[_._v("#")]),_._v(" 三次握手可以携带数据吗？")]),_._v(" "),v("p",[_._v("第一次、第二次握手不可以携带数据，而第三次握手是可以携带数据的。")]),_._v(" "),v("p",[_._v("我们可以思考一个问题，假如第一次握手可以携带数据的话，如果有人要恶意攻击服务器，那他每次都在第一次握手中的 SYN 报文中放入大量的数据，疯狂着重复发 SYN 报文，这会让服务器花费大量的内存空间来缓存这些报文，这样服务器就更容易被攻击了。")]),_._v(" "),v("p",[_._v("对于第三次握手，此时客户端已经处于连接状态，他已经知道服务器的接收、发送能力是正常的了，所以可以携带数据是情理之中。")]),_._v(" "),v("h2",{attrs:{id:"tcp-断开连接四次挥手"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#tcp-断开连接四次挥手"}},[_._v("#")]),_._v(" TCP 断开连接四次挥手")]),_._v(" "),v("h3",{attrs:{id:"四次挥手的过程-需要说明状态转换"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#四次挥手的过程-需要说明状态转换"}},[_._v("#")]),_._v(" 四次挥手的过程，需要说明状态转换")]),_._v(" "),v("ul",[v("li",[_._v("第一次挥手。客户端发起 "),v("code",[_._v("FIN")]),_._v(" 包（FIN = 1）,客户端进入 "),v("code",[_._v("FIN_WAIT_1")]),_._v(" 状态。TCP 规定，即使 "),v("code",[_._v("FIN")]),_._v(" 包不携带数据，也要消耗一个序号。")]),_._v(" "),v("li",[_._v("第二次挥手。服务器端收到 "),v("code",[_._v("FIN")]),_._v(" 包，发出确认包 "),v("code",[_._v("ACK")]),_._v("（ack = u + 1），并带上自己的序号 seq=v，服务器端进入了 "),v("code",[_._v("CLOSE_WAIT")]),_._v(" 状态。这个时候客户端已经没有数据要发送了，不过服务器端有数据发送的话，客户端依然需要接收。客户端接收到服务器端发送的 "),v("code",[_._v("ACK")]),_._v(" 后，进入了 "),v("code",[_._v("FIN_WAIT_2")]),_._v(" 状态。")]),_._v(" "),v("li",[_._v("第三次挥手。服务器端数据发送完毕后，向客户端发送 "),v("code",[_._v("FIN")]),_._v(" 包（seq=w ack=u+1），半连接状态下服务器可能又发送了一些数据，假设发送 seq 为 w。服务器此时进入了 "),v("code",[_._v("LAST_ACK")]),_._v(" 状态。")]),_._v(" "),v("li",[_._v("第四次挥手。客户端收到服务器的 "),v("code",[_._v("FIN")]),_._v(" 包后，发出确认包（ACK=1，ack=w+1），此时客户端就进入了 "),v("code",[_._v("TIME_WAIT")]),_._v(" 状态。注意此时 TCP 连接还没有释放，必须经过 "),v("code",[_._v("2*MSL")]),_._v(" 后，才进入 "),v("code",[_._v("CLOSED")]),_._v(" 状态。而服务器端收到客户端的确认包 "),v("code",[_._v("ACK")]),_._v(" 后就进入了 "),v("code",[_._v("CLOSED")]),_._v(" 状态，可以看出服务器端结束 TCP 连接的时间要比客户端早一些。")])]),_._v(" "),v("h3",{attrs:{id:"为什么建立连接握手三次-关闭连接时需要是四次呢"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#为什么建立连接握手三次-关闭连接时需要是四次呢"}},[_._v("#")]),_._v(" 为什么建立连接握手三次，关闭连接时需要是四次呢？")]),_._v(" "),v("p",[_._v("其实在 TCP 握手的时候，接收端发送 "),v("code",[_._v("SYN+ACK")]),_._v(" 的包是将一个 "),v("code",[_._v("ACK")]),_._v(" 和一个 "),v("code",[_._v("SYN")]),_._v(" 合并到一个包中，所以减少了一次包的发送，三次完成握手。")]),_._v(" "),v("p",[_._v("对于四次挥手，因为 TCP 是全双工通信，在主动关闭方发送 FIN 包后，接收端可能还要发送数据，不能立即关闭服务器端到客户端的数据通道，所以也就不能将服务器端的 "),v("code",[_._v("FIN")]),_._v(" 包与对客户端的 "),v("code",[_._v("ACK")]),_._v(" 包合并发送，只能先确认 "),v("code",[_._v("ACK")]),_._v("，然后服务器待无需发送数据时再发送 "),v("code",[_._v("FIN")]),_._v(" 包，所以四次挥手时必须是四次数据包的交互。")]),_._v(" "),v("h3",{attrs:{id:"为什么time-wait-状态需要经过-2msl-才能返回到-close-状态"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#为什么time-wait-状态需要经过-2msl-才能返回到-close-状态"}},[_._v("#")]),_._v(" 为什么TIME_WAIT 状态需要经过 2MSL 才能返回到 CLOSE 状态？")]),_._v(" "),v("p",[v("code",[_._v("MSL")]),_._v(" 指的是报文在网络中最大生存时间。在客户端发送对服务器端的 "),v("code",[_._v("FIN")]),_._v(" 的确认包 "),v("code",[_._v("ACK")]),_._v(" 后，这个 "),v("code",[_._v("ACK")]),_._v(" 包是有可能不可达的，服务器端如果收不到 "),v("code",[_._v("ACK")]),_._v(" 的话需要重新发送 "),v("code",[_._v("FIN")]),_._v(" 包。")]),_._v(" "),v("p",[_._v("所以客户端发送 "),v("code",[_._v("ACK")]),_._v(" 后需要留出 "),v("code",[_._v("2MSL")]),_._v(" 时间（ACK 到达服务器 + 服务器发送 FIN 重传包，一来一回）等待确认服务器端确实收到了 ACK 包。")]),_._v(" "),v("p",[_._v("也就是说客户端如果等待 "),v("code",[_._v("2MSL")]),_._v(" 时间也没有收到服务器端的重传包 "),v("code",[_._v("FIN")]),_._v("，说明可以确认服务器已经收到客户端发送的 "),v("code",[_._v("ACK")]),_._v("。")]),_._v(" "),v("p",[_._v("还有第 "),v("em",[_._v("2")]),_._v(" 个理由，避免新旧连接混淆。")]),_._v(" "),v("p",[_._v("在客户端发送完最后一个 "),v("code",[_._v("ACK")]),_._v(" 报文段后，在经过 "),v("code",[_._v("2MSL")]),_._v(" 时间，就可以使本连接持续的时间内所产生的所有报文都从网络中消失，使下一个新的连接中不会出现这种旧的连接请求报文。")]),_._v(" "),v("p",[_._v("你要知道，有些自作主张的路由器会缓存 IP 数据包，如果连接重用了，那么这些延迟收到的包就有可能会跟新连接混在一起。")])])}),[],!1,null,null,null);v.default=r.exports}}]);