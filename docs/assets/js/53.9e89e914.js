(window.webpackJsonp=window.webpackJsonp||[]).push([[53],{355:function(t,v,a){"use strict";a.r(v);var _=a(6),s=Object(_.a)({},(function(){var t=this,v=t._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h2",{attrs:{id:"math3d库向量"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#math3d库向量"}},[t._v("#")]),t._v(" math3d库向量")]),t._v(" "),v("p",[t._v("math3d库包含两个数据类型")]),t._v(" "),v("ul",[v("li",[t._v("M3DVector3f 三维向量  (x, y, z)")]),t._v(" "),v("li",[t._v("M3DVector4f 四维向量（x, y, z, w）")])]),t._v(" "),v("p",[t._v("在典型情况下，w 坐标设为1.0。x,y,z值通过除以w，来进行缩放。⽽除以1.0则本质上不改变x,y,z值。")]),t._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[t._v("typedef float M3DVector3f[3];\ntypedef float M3DVector4f[4];\n\n// 声明⼀个三维向量操作:\nM3DVector3f vVector;\n// 类似，声明⼀个四维向量的操作:\nM3DVector4f vVectro= {0.0f,0.0f,1.0f,1.0f};\n\n// 声明⼀个三维向量顶点数组，例如⽣成⼀个三角形\nM3DVector3f vVerts[] = {\n\t-0.5f, 0.0f, 0.0f,\n\t0.5f, 0.0f, 0.0f,\n\t-0.0f, 0.5f, 0.0f,\n};\n")])])]),v("h2",{attrs:{id:"向量"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#向量"}},[t._v("#")]),t._v(" 向量")]),t._v(" "),v("p",[t._v("向量大小")]),t._v(" "),v("p",[t._v("标量与向量乘法")]),t._v(" "),v("p",[t._v("标量与向量的除法")]),t._v(" "),v("p",[t._v("标准化向量")]),t._v(" "),v("p",[t._v("向量加减法")]),t._v(" "),v("h2",{attrs:{id:"向量点乘"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#向量点乘"}},[t._v("#")]),t._v(" 向量点乘")]),t._v(" "),v("p",[t._v("向量的点乘,也叫向量的内积、数量积，对两个向量执行点乘运算，就是对这两个向量对应位一一相乘之后求和的操作，点乘的结果是一个标量。")]),t._v(" "),v("p",[t._v("例如：向量a和向量b")]),t._v(" "),v("ul",[v("li",[t._v("a=[a1, a2, a3, ...an];")]),t._v(" "),v("li",[t._v("b=[b1, b2, b3, ...bn];")]),t._v(" "),v("li",[t._v("a和b点乘 = a1b1 + a2b2 + a3b3 + ... + anbn;")])]),t._v(" "),v("p",[v("strong",[t._v("几何意义：")])]),t._v(" "),v("p",[t._v("点乘的几何意义是可以用来表征或计算两个向量之间的"),v("strong",[t._v("夹角")]),t._v("，以及在b向量在a向量方向上的投影")]),t._v(" "),v("p",[v("strong",[t._v("公式：")])]),t._v(" "),v("p",[t._v("​"),v("img",{attrs:{src:"https://img-blog.csdn.net/20160902220238078",alt:"img"}}),t._v("​")]),t._v(" "),v("p",[t._v("结论：")]),t._v(" "),v("ul",[v("li",[t._v("a·b>0   方向基本相同，夹角在0°到90°之间")]),t._v(" "),v("li",[t._v("a·b=0   正交，相互垂直")]),t._v(" "),v("li",[t._v("a·b<0   方向基本相反，夹角在90°到180°之间")])]),t._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[t._v("//实现点乘⽅法: \n//⽅法1:返回的是-1，1之间的值。它代表这个2个向量的余弦值。\nfloat m3dDotProduct3(const M3DVector3f u,const M3DVector3f v);\n\n//⽅法2:返回2个向量之间的弧度值。\nfloat m3dGetAngleBetweenVector3(const M3DVector3f u,const M3DVector3f v);\n")])])]),v("h2",{attrs:{id:"向量叉乘"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#向量叉乘"}},[t._v("#")]),t._v(" 向量叉乘")]),t._v(" "),v("p",[t._v("叉乘的运算结果是一个向量而不是一个标量。结果向量与这两个向量组成的坐标平面垂直。")]),t._v(" "),v("p",[v("strong",[t._v("公式：")])]),t._v(" "),v("p",[t._v("​"),v("img",{attrs:{src:"https://img-blog.csdn.net/20160902230539163",alt:"img"}}),t._v("​")]),t._v(" "),v("p",[t._v("​"),v("img",{attrs:{src:"https://img-blog.csdn.net/20160902231520146",alt:"img"}}),t._v("​")]),t._v(" "),v("p",[t._v("其中i，j，k")]),t._v(" "),v("p",[t._v("​"),v("img",{attrs:{src:"https://img-blog.csdn.net/20160902231657984",alt:"img"}}),t._v("​")]),t._v(" "),v("p",[t._v("根据i、j、k间关系，有：")]),t._v(" "),v("p",[t._v("​"),v("img",{attrs:{src:"https://img-blog.csdn.net/20160902232255082",alt:"img"}}),t._v("​")]),t._v(" "),v("p",[v("strong",[t._v("在二维空间中，叉乘还有另外一个几何意义就是：aXb等于由向量a和向量b构成的平行四边形的面积。")])]),t._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[t._v("void m3dCrossProduct3(M3DVector3f result,const M3DVector3f u ,const M3DVector3f v);\n")])])]),v("h2",{attrs:{id:"opengl-矩阵"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#opengl-矩阵"}},[t._v("#")]),t._v(" OpenGL 矩阵")]),t._v(" "),v("ul",[v("li",[t._v("typedef float M3DMatrix33f[9];")]),t._v(" "),v("li",[t._v("typedef float M3DMatrix44f[16];")])]),t._v(" "),v("p",[t._v("​"),v("img",{attrs:{src:"http://xingyajie.oss-cn-hangzhou.aliyuncs.com/uPic/image-20220726074901432.png",alt:"image-20220726074901432"}}),t._v("​")]),t._v(" "),v("p",[v("strong",[t._v("对角线元素")]),t._v("：行号等于列号的元素")]),t._v(" "),v("p",[v("strong",[t._v("单元矩阵")]),t._v("：对角线元素为1，其他元素为0")]),t._v(" "),v("p",[t._v("任何矩阵乘以单元矩阵，结果都是他本身")]),t._v(" "),v("p",[v("strong",[t._v("方阵")]),t._v("：行数和列数相同的矩阵")]),t._v(" "),v("p",[v("strong",[t._v("矩阵乘法")]),t._v("：标量与矩阵，矩阵与矩阵")]),t._v(" "),v("ul",[v("li",[t._v("当矩阵A的列数（column）等于矩阵B的行数（row）时，A与B"),v("strong",[t._v("可以相乘")]),t._v("。")]),t._v(" "),v("li",[t._v("任意矩阵M乘以方阵S,不管从哪边乘，都得到与原矩阵⼤小相同的矩阵。当然，前提是假定乘法有意义。如果S是单位 矩阵，结果就是原矩阵M，即:MI = IM = M")]),t._v(" "),v("li",[t._v("矩阵乘法不满⾜交换律，即:AB != BA")]),t._v(" "),v("li",[t._v("矩阵乘法满⾜结合律，即:(AB)C = A(BC)。假定ABC的维数使得其乘法有意义，要注意如果(AB)C有意义，那么A(BC)就⼀定有意义。")]),t._v(" "),v("li",[t._v("矩阵乘法也满⾜与标量或向量的结合律律，即:(kA)B = k(AB) = A(kB); (vA)B = v(AB);")]),t._v(" "),v("li",[t._v("矩阵积的转置相当于先转置矩阵然后以相反的顺序乘法，即:(AB)T = BT AT")])]),t._v(" "),v("h2",{attrs:{id:"向量与矩阵乘法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#向量与矩阵乘法"}},[t._v("#")]),t._v(" 向量与矩阵乘法")])])}),[],!1,null,null,null);v.default=s.exports}}]);