(window.webpackJsonp=window.webpackJsonp||[]).push([[18],{327:function(e,o,n){"use strict";n.r(o);var r=n(6),a=Object(r.a)({},(function(){var e=this,o=e._self._c;return o("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[o("h2",{attrs:{id:"runloop"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#runloop"}},[e._v("#")]),e._v(" RunLoop")]),e._v(" "),o("p",[e._v("运行循环。在程序运行过程中循环做一些事情")]),e._v(" "),o("p",[e._v("作用：")]),e._v(" "),o("ul",[o("li",[e._v("保持程序的持续运行")]),e._v(" "),o("li",[e._v("处理App中的各种事件（比如触摸事件、定时器事件等）")]),e._v(" "),o("li",[e._v("节省CPU资源，提高程序性能：该做事时做事，该休息时休息")]),e._v(" "),o("li",[e._v("......")])]),e._v(" "),o("p",[e._v("应用范畴:")]),e._v(" "),o("ul",[o("li",[e._v("定时器（Timer）、PerformSelector")]),e._v(" "),o("li",[e._v("GCD Async Main Queue")]),e._v(" "),o("li",[e._v("事件响应、手势识别、界面刷新")]),e._v(" "),o("li",[e._v("网络请求")]),e._v(" "),o("li",[e._v("AutoreleasePool")])]),e._v(" "),o("h2",{attrs:{id:"runloop与线程"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#runloop与线程"}},[e._v("#")]),e._v(" RunLoop与线程")]),e._v(" "),o("p",[e._v("每条线程都有唯一的一个与之对应的RunLoop对象")]),e._v(" "),o("p",[e._v("RunLoop保存在一个全局的Dictionary里，线程作为key，RunLoop作为value")]),e._v(" "),o("p",[e._v("线程刚创建时并没有RunLoop对象，RunLoop会在第一次获取它时创建")]),e._v(" "),o("p",[e._v("RunLoop会在线程结束时销毁")]),e._v(" "),o("p",[e._v("主线程的RunLoop已经自动获取（创建），子线程默认没有开启RunLoop")]),e._v(" "),o("h2",{attrs:{id:"获取runloop"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#获取runloop"}},[e._v("#")]),e._v(" 获取RunLoop")]),e._v(" "),o("div",{staticClass:"language-objective-c extra-class"},[o("pre",{pre:!0,attrs:{class:"language-text"}},[o("code",[e._v("// Foundation\n[NSRunLoop currentRunLoop]; // 获得当前线程的RunLoop对象\n[NSRunLoop mainRunLoop]; // 获得主线程的RunLoop对象\n\n// Core Foundation\t\nCFRunLoopGetCurrent(); // 获得当前线程的RunLoop对象\nCFRunLoopGetMain(); // 获得主线程的RunLoop对象\n")])])]),o("h2",{attrs:{id:"runloop相关类"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#runloop相关类"}},[e._v("#")]),e._v(" RunLoop相关类")]),e._v(" "),o("p",[e._v("Core Foundation中关于RunLoop的5个类")]),e._v(" "),o("ul",[o("li",[e._v("CFRunLoopRef")]),e._v(" "),o("li",[e._v("CFRunLoopModeRef")]),e._v(" "),o("li",[e._v("CFRunLoopSourceRef")]),e._v(" "),o("li",[e._v("CFRunLoopTimerRef")]),e._v(" "),o("li",[e._v("CFRunLoopObserverRef")])]),e._v(" "),o("p",[o("img",{attrs:{src:"http://xingyajie.oss-cn-hangzhou.aliyuncs.com/uPic/image-20220607203745744.png",alt:"image-20220607203745744"}})]),e._v(" "),o("p",[o("img",{attrs:{src:"http://xingyajie.oss-cn-hangzhou.aliyuncs.com/uPic/image-20220607203712802.png",alt:"image-20220607203712802"}})]),e._v(" "),o("p",[o("img",{attrs:{src:"http://xingyajie.oss-cn-hangzhou.aliyuncs.com/uPic/image-20220607203727018.png",alt:"image-20220607203727018"}})]),e._v(" "),o("h3",{attrs:{id:"cfrunloopmoderef"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#cfrunloopmoderef"}},[e._v("#")]),e._v(" CFRunLoopModeRef")]),e._v(" "),o("ul",[o("li",[e._v("CFRunLoopModeRef代表RunLoop的运行模式")]),e._v(" "),o("li",[e._v("一个RunLoop包含若干个Mode，每个Mode又包含若干个Source0/Source1/Timer/Observer")]),e._v(" "),o("li",[e._v("RunLoop启动时只能选择其中一个Mode，作为currentMode")]),e._v(" "),o("li",[e._v("如果需要切换Mode，只能退出当前Loop，再重新选择一个Mode进入\n"),o("ul",[o("li",[e._v("不同组的Source0/Source1/Timer/Observer能分隔开来，互不影响")])])]),e._v(" "),o("li",[e._v("如果Mode里没有任何Source0/Source1/Timer/Observer，RunLoop会立马退出")])]),e._v(" "),o("p",[e._v("常见的2种Mode")]),e._v(" "),o("ul",[o("li",[e._v("kCFRunLoopDefaultMode（NSDefaultRunLoopMode）：App的默认Mode，通常主线程是在这个Mode下运")]),e._v(" "),o("li",[e._v("UITrackingRunLoopMode：界面跟踪 Mode，用于 ScrollView 追踪触摸滑动，保证界面滑动时不受其他 Mode 影响")])]),e._v(" "),o("h3",{attrs:{id:"cfrunloopobserverref"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#cfrunloopobserverref"}},[e._v("#")]),e._v(" CFRunLoopObserverRef")]),e._v(" "),o("p",[o("img",{attrs:{src:"http://xingyajie.oss-cn-hangzhou.aliyuncs.com/uPic/image-20220607204418900.png",alt:"image-20220607204418900"}})]),e._v(" "),o("h3",{attrs:{id:"cfrunloopsourceref"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#cfrunloopsourceref"}},[e._v("#")]),e._v(" CFRunLoopSourceRef")]),e._v(" "),o("p",[e._v("Source0\n触摸事件处理\nperformSelector:onThread:")]),e._v(" "),o("p",[e._v("Source1\n基于Port的线程间通信\n系统事件捕捉")]),e._v(" "),o("h3",{attrs:{id:"cfrunlooptimerref"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#cfrunlooptimerref"}},[e._v("#")]),e._v(" CFRunLoopTimerRef")]),e._v(" "),o("p",[e._v("Timers\nNSTimer\nperformSelector:withObject:afterDelay:")]),e._v(" "),o("h3",{attrs:{id:"cfrunloopobserverref-2"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#cfrunloopobserverref-2"}},[e._v("#")]),e._v(" CFRunLoopObserverRef")]),e._v(" "),o("p",[e._v("Observers\n用于监听RunLoop的状态\nUI刷新（BeforeWaiting）\nAutorelease pool（BeforeWaiting）")]),e._v(" "),o("h2",{attrs:{id:"添加observer监听runloop的所有状态"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#添加observer监听runloop的所有状态"}},[e._v("#")]),e._v(" 添加Observer监听RunLoop的所有状态")]),e._v(" "),o("p",[o("img",{attrs:{src:"http://xingyajie.oss-cn-hangzhou.aliyuncs.com/uPic/image-20220607204546406.png",alt:"image-20220607204546406"}})]),e._v(" "),o("h2",{attrs:{id:"runloop的运行逻辑"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#runloop的运行逻辑"}},[e._v("#")]),e._v(" RunLoop的运行逻辑")]),e._v(" "),o("p",[o("img",{attrs:{src:"http://xingyajie.oss-cn-hangzhou.aliyuncs.com/uPic/image-20220607204610636.png",alt:"image-20220607204610636"}})]),e._v(" "),o("p",[e._v("具体流程：")]),e._v(" "),o("ul",[o("li",[e._v("01、通知Observers：进入Loop")]),e._v(" "),o("li",[e._v("02、通知Observers：即将处理Timers")]),e._v(" "),o("li",[e._v("03、通知Observers：即将处理Sources")]),e._v(" "),o("li",[e._v("04、处理Blocks")]),e._v(" "),o("li",[e._v("05、处理Source0（可能会再次处理Blocks）")]),e._v(" "),o("li",[e._v("06、如果存在Source1，就跳转到第8步")]),e._v(" "),o("li",[e._v("07、通知Observers：开始休眠（等待消息唤醒）")]),e._v(" "),o("li",[e._v("08、通知Observers：结束休眠（被某个消息唤醒）\n"),o("ul",[o("li",[e._v("01> 处理Timer")]),e._v(" "),o("li",[e._v("02> 处理GCD Async To Main Queue")]),e._v(" "),o("li",[e._v("03> 处理Source1")])])]),e._v(" "),o("li",[e._v("09、处理Blocks")]),e._v(" "),o("li",[e._v("10、根据前面的执行结果，决定如何操作\n"),o("ul",[o("li",[e._v("01> 回到第02步")]),e._v(" "),o("li",[e._v("02> 退出Loop")])])]),e._v(" "),o("li",[e._v("11、通知Observers：退出Loop")])]),e._v(" "),o("p",[o("img",{attrs:{src:"http://xingyajie.oss-cn-hangzhou.aliyuncs.com/uPic/image-20220607205420166.png",alt:"image-20220607205420166"}})]),e._v(" "),o("h2",{attrs:{id:"runloop休眠的实现原理"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#runloop休眠的实现原理"}},[e._v("#")]),e._v(" RunLoop休眠的实现原理")]),e._v(" "),o("p",[o("img",{attrs:{src:"http://xingyajie.oss-cn-hangzhou.aliyuncs.com/uPic/image-20220607205450788.png",alt:"image-20220607205450788"}})]),e._v(" "),o("h2",{attrs:{id:"runloop在实际开中的应用"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#runloop在实际开中的应用"}},[e._v("#")]),e._v(" RunLoop在实际开中的应用")]),e._v(" "),o("ul",[o("li",[e._v("控制线程生命周期（线程保活）")]),e._v(" "),o("li",[e._v("解决NSTimer在滑动时停止工作的问题")]),e._v(" "),o("li",[e._v("监控应用卡顿")]),e._v(" "),o("li",[e._v("性能优化")])]),e._v(" "),o("h2",{attrs:{id:"线程保活"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#线程保活"}},[e._v("#")]),e._v(" 线程保活")]),e._v(" "),o("div",{staticClass:"language-objective-c extra-class"},[o("pre",{pre:!0,attrs:{class:"language-text"}},[o("code",[e._v('/** XYJThread **/\n@interface XYJThread : NSThread\n@end\n@implementation XYJThread\n- (void)dealloc\n{\n    NSLog(@"%s", __func__);\n}\n@end\n\n/** XYJPermenantThread **/\n@interface XYJPermenantThread()\n@property (strong, nonatomic) XYJThread *innerThread;\n@end\n\n@implementation XYJPermenantThread\n\n#pragma mark - public methods\n- (instancetype)init\n{\n    if (self = [super init]) {\n        self.innerThread = [[XYJThread alloc] initWithBlock:^{\n            // 创建上下文（要初始化一下结构体）\n            CFRunLoopSourceContext context = {0};  \n            // 创建source\n            CFRunLoopSourceRef source = CFRunLoopSourceCreate(kCFAllocatorDefault, 0, &context);\n            // 往Runloop中添加source\n            CFRunLoopAddSource(CFRunLoopGetCurrent(), source, kCFRunLoopDefaultMode);\n            // 销毁source\n            CFRelease(source);\n            // 启动\n          \t// 第3个参数：returnAfterSourceHandled，设置为true，代表执行完source后就会退出当前\n            CFRunLoopRunInMode(kCFRunLoopDefaultMode, 1.0e10, false);\n        }];\n        \n        [self.innerThread start];\n    }\n    return self;\n}\n\n- (void)executeTask:(XYJPermenantThreadTask)task {\n    if (!self.innerThread || !task) return;\n    [self performSelector:@selector(__executeTask:) onThread:self.innerThread withObject:task waitUntilDone:NO];\n}\n\n- (void)stop {\n    if (!self.innerThread) return;\n    [self performSelector:@selector(__stop) onThread:self.innerThread withObject:nil waitUntilDone:YES];\n}\n\n- (void)dealloc {\n    [self stop];\n}\n\n#pragma mark - private methods\n- (void)__stop {\n    CFRunLoopStop(CFRunLoopGetCurrent());\n    self.innerThread = nil;\n}\n\n- (void)__executeTask:(XYJPermenantThreadTask)task {\n    task();\n}\n\n@end\n\n')])])])])}),[],!1,null,null,null);o.default=a.exports}}]);