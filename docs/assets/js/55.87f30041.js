(window.webpackJsonp=window.webpackJsonp||[]).push([[55],{356:function(t,a,n){"use strict";n.r(a);var s=n(6),e=Object(s.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h2",{attrs:{id:"glsl语言"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#glsl语言"}},[t._v("#")]),t._v(" GLSL语言")]),t._v(" "),a("p",[t._v("xcode中不支持GLSL语言对顶点/片元着色器的编译和连接，因此需要在项目中创建两个空文件，分别命名为"),a("code",[t._v("shader.vsh")]),t._v("​和"),a("code",[t._v("shaderv.fsh")]),t._v("​")]),t._v(" "),a("ul",[a("li",[t._v("使用"),a("code",[t._v("vsh、fsh")]),t._v("​后缀的原因是方便区分着色器，其本质就是一个字符串")]),t._v(" "),a("li",[t._v("是否可以直接使用NSString？并不建议这样做，因为代码结构不清晰，不易读")]),t._v(" "),a("li",[t._v("这两个文件中是否可以加中文注释？不建议加中文注释，会报奇怪的错误，由于在xcode中书写GLSL，完全是纯手写，没有任何提示，排查问题不好排查")])]),t._v(" "),a("h3",{attrs:{id:"向量数据类型"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#向量数据类型"}},[t._v("#")]),t._v(" 向量数据类型")]),t._v(" "),a("table",[a("thead",[a("tr",[a("th",[t._v("类型")]),t._v(" "),a("th",[t._v("描述")])])]),t._v(" "),a("tbody",[a("tr",[a("td",[t._v("vec2,vec3,vec4")]),t._v(" "),a("td",[t._v("2分量、3分量、4分量浮点向量")])]),t._v(" "),a("tr",[a("td",[t._v("ivec2,ivec3,ivec4")]),t._v(" "),a("td",[t._v("2分量、3分量、4分量整型向量")])]),t._v(" "),a("tr",[a("td",[t._v("uvec2,uvec3,uvec4")]),t._v(" "),a("td",[t._v("2分量、3分量、4分量无符号整型向量")])]),t._v(" "),a("tr",[a("td",[t._v("bvec2,bvec3,bvec4")]),t._v(" "),a("td",[t._v("2分量、3分量、4分量bool型向量")])])])]),t._v(" "),a("p",[t._v("常用的是"),a("code",[t._v("vec2、vec3、vec4")]),t._v("​，默认是浮点类型")]),t._v(" "),a("h3",{attrs:{id:"矩阵数据类型"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#矩阵数据类型"}},[t._v("#")]),t._v(" 矩阵数据类型")]),t._v(" "),a("table",[a("thead",[a("tr",[a("th",[t._v("类型（mat列×行）")]),t._v(" "),a("th",[t._v("描述")])])]),t._v(" "),a("tbody",[a("tr",[a("td",[t._v("mat2,mat2x2")]),t._v(" "),a("td",[t._v("两⾏两列")])]),t._v(" "),a("tr",[a("td",[t._v("mat3,mat3x3")]),t._v(" "),a("td",[t._v("三行三列")])]),t._v(" "),a("tr",[a("td",[t._v("mat4,mat4x4")]),t._v(" "),a("td",[t._v("四行四列")])]),t._v(" "),a("tr",[a("td",[t._v("mat2x3")]),t._v(" "),a("td",[t._v("三行两列")])]),t._v(" "),a("tr",[a("td",[t._v("mat2x4")]),t._v(" "),a("td",[t._v("四行两列")])]),t._v(" "),a("tr",[a("td",[t._v("mat3x2")]),t._v(" "),a("td",[t._v("两行三列")])]),t._v(" "),a("tr",[a("td",[t._v("mat3x4")]),t._v(" "),a("td",[t._v("四行三列")])]),t._v(" "),a("tr",[a("td",[t._v("mat4x2")]),t._v(" "),a("td",[t._v("两行四列")])]),t._v(" "),a("tr",[a("td",[t._v("mat4x3")]),t._v(" "),a("td",[t._v("三行四列")])])])]),t._v(" "),a("p",[t._v("常用的是"),a("code",[t._v("vec2、vec3、vec4")]),t._v("​，默认是浮点类型")]),t._v(" "),a("h3",{attrs:{id:"变量存储限定符"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#变量存储限定符"}},[t._v("#")]),t._v(" 变量存储限定符")]),t._v(" "),a("table",[a("thead",[a("tr",[a("th",[t._v("限定符")]),t._v(" "),a("th",[t._v("描述")])])]),t._v(" "),a("tbody",[a("tr",[a("td",[a("none")],1),t._v(" "),a("td",[t._v("只是普通的本地变量，外部不见，外部不可访问")])]),t._v(" "),a("tr",[a("td",[t._v("const")]),t._v(" "),a("td",[t._v("⼀个编译常量，或者说是⼀个对函数来说为只读的参数")])]),t._v(" "),a("tr",[a("td",[t._v("in/varying")]),t._v(" "),a("td",[t._v("从以前阶段传递过来的变量")])]),t._v(" "),a("tr",[a("td",[t._v("in/varying centroid")]),t._v(" "),a("td",[t._v("⼀个从以前的阶段传递过来的变量，使⽤质⼼插值")])]),t._v(" "),a("tr",[a("td",[t._v("out/attribute")]),t._v(" "),a("td",[t._v("传递到下⼀个处理阶段或者在⼀个函数中指定⼀个返回值")])]),t._v(" "),a("tr",[a("td",[t._v("out/attribute centroid")]),t._v(" "),a("td",[t._v("传递到下⼀个处理阶段，质心插值")])]),t._v(" "),a("tr",[a("td",[t._v("uniform")]),t._v(" "),a("td",[t._v("⼀个从客户端代码传递过来的变量，在顶点之间不做改变")])])])]),t._v(" "),a("p",[t._v("常用"),a("code",[t._v("varying、attribute、uniform")]),t._v("​")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("varying 修饰符：当需要将顶点着色器的数据传递到片元着色器时，两个着色器中一模一样的纹理坐标变量就需要它来修饰")])]),t._v(" "),a("li",[a("p",[t._v("attribute：数据只能从客户端中传递到顶点着色器，且只能在顶点着色器中使用")]),t._v(" "),a("ul",[a("li",[t._v("修饰的数据：顶点、纹理、颜色、法线等")]),t._v(" "),a("li",[t._v("API通常以"),a("code",[t._v("glVertex...")]),t._v("​开头，例如"),a("code",[t._v("glVertexAttribPointer")]),t._v("​")]),t._v(" "),a("li",[t._v("其中的纹理坐标，需要顶点着色器间接传递到片元着色器，需要在顶点与片元着色器中定义一个一模一样的纹理坐标，通过这个变量将纹理坐标数据间接传递到片元着色器，"),a("code",[t._v("varying lowp vec2 varyTextCoord;")]),t._v("​")]),t._v(" "),a("li",[t._v("顶点着色器计算之后的顶点结果需要赋值给GLSL的内建变量"),a("code",[t._v("gl_Position")]),t._v("​")])])])]),t._v(" "),a("div",{staticClass:"language-cpp extra-class"},[a("pre",{pre:!0,attrs:{class:"language-cpp"}},[a("code",[t._v("attribute vec4 position"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\nattribute vec2 textCoordinate"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\nvarying lowp vec2 varyTextCoord"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("main")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    varyTextCoord "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" textCoordinate"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    gl_Position "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" position"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("ul",[a("li",[a("p",[t._v("uniform：从app代码传递到vertex、fragment中所用的变量")]),t._v(" "),a("ul",[a("li",[t._v("在vertex，fragment中一般将uniform当成常量")]),t._v(" "),a("li",[t._v("uniform可以传的数据：视图矩阵、投影矩阵、投影视图矩阵")]),t._v(" "),a("li",[t._v("API通常以"),a("code",[t._v("glUniform...")]),t._v("​开头")]),t._v(" "),a("li",[t._v("片元着色器中最终颜色，即拿到纹理对应坐标下的纹素。纹素是纹理对应像素点的颜色值，需要通过内建函数"),a("code",[t._v("texture2D(纹理，纹理坐标)")]),t._v("​计算，将最终返回的颜色值赋值给内建变量"),a("code",[t._v("gl_FragColor")]),t._v("​")])])])]),t._v(" "),a("div",{staticClass:"language-cpp extra-class"},[a("pre",{pre:!0,attrs:{class:"language-cpp"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//需要定义精度，否则可能会报错")]),t._v("\nprecsion highp "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("float")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//纹理坐标 必须与顶点着色器中一模一样,通过这个参数获取传递过来的值")]),t._v("\nvarying lowp vec2 varyTextCoord"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//纹理 ")]),t._v("\nuniform sampler2D colorMap"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("   \n\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("main")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//1、拿到纹理对应坐标下的纹素。纹素是纹理对应像素点的颜色值")]),t._v("\n    lowp vec4 temp "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("texture2D")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("colorMap"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" varyTextCoord"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  \n    "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//2、非常重要且必须的内建变量：gl_FragColor")]),t._v("\n    gl_FragColor "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" temp；\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" \n")])])]),a("h2",{attrs:{id:"着色器与程序-的编译-与链接"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#着色器与程序-的编译-与链接"}},[t._v("#")]),t._v(" 着色器与程序 的编译 与链接")]),t._v(" "),a("p",[t._v("需要创建2个基本对象才能使用着色器进行传染：着色器对象和程序对象")]),t._v(" "),a("p",[t._v("获取链接后着色器对象一般的编译&链接分为6步：")]),t._v(" "),a("ul",[a("li",[t._v("创建一个顶点着色器对象和一个片元着色器对象")]),t._v(" "),a("li",[t._v("将源代码链接到每个着色器对象")]),t._v(" "),a("li",[t._v("编译着色器对象")]),t._v(" "),a("li",[t._v("创建一个程序对象")]),t._v(" "),a("li",[t._v("将编译后的着色器对象连接到程序对象")]),t._v(" "),a("li",[t._v("链接程序对象")])]),t._v(" "),a("h2",{attrs:{id:"常用api"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#常用api"}},[t._v("#")]),t._v(" 常用API")]),t._v(" "),a("h3",{attrs:{id:"自定义着色器"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#自定义着色器"}},[t._v("#")]),t._v(" 自定义着色器")]),t._v(" "),a("p",[t._v("自定义着色器一般有以下步骤：")]),t._v(" "),a("ul",[a("li",[t._v("创建顶点着色器/片元着色器 --"),a("code",[t._v("glCreateShader")]),t._v("​")]),t._v(" "),a("li",[t._v("指定shader的source --"),a("code",[t._v("glShaderSource")]),t._v("​")]),t._v(" "),a("li",[t._v("编译shader --"),a("code",[t._v("glCompileShader")]),t._v("​")])]),t._v(" "),a("h3",{attrs:{id:"创建与编译一个着色器"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#创建与编译一个着色器"}},[t._v("#")]),t._v(" 创建与编译一个着色器")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("GLuint glCreateShader(GLenum type);\n// type — 创建着色器的类型,GL_VERTEX_SHADER 或者GL_FRAGMENT_SHADER\n// 返回值 — 是指向新着⾊器对象的句柄.可以调用glDeleteShader 删除 \n\nvoid glDeleteShader(GLuint shader);\n// shader — 要删除的着⾊器对象句柄\n\nvoid glShaderSource(GLuint shader , GLSizei count ,const GLChar * const *string, const GLint *length);\n// shader — 指向着⾊器对象的句柄\n// count — 着⾊器源字符串的数量,着⾊器可以由多个源字符串组成,但是每个着⾊器只有⼀个main函数 \n// string — 指向保存数量的count 的着⾊器源字符串的数组指针\n// length — 指向保存每个着⾊器字符串大小且元素数量为count 的整数组指针\n\nvoid glCompileShader(GLuint shader); \n// shader — 需要编译的着⾊器对象句柄\n\nvoid glGetShaderiv(GLuint shader , GLenum pname , GLint *params );\n// shader — 需要编译的着⾊器对象句柄\n// pname — 获取的信息参数,可以为 GL_COMPILE_STATUS/GL_DELETE_STATUS/ GL_INFO_LOG_LENGTH/GL_SHADER_SOURCE_LENGTH/ GL_SHADER_TYPE\n// params — 指向查询结果的整数存储位置的指针.\n\nvoid glGetShaderInfolog(GLuint shader , GLSizei maxLength, GLSizei *length , GLChar *infoLog);\n// shader — 需要获取信息⽇志的着⾊器对象句柄\n// maxLength — 保存信息日志的缓存区⼤小\n// length — 写⼊的信息日志的⻓度(减去null 终⽌符); 如果不需要知道长度. 这个参数可以为Null \n// infoLog — 指向保存信息日志的字符缓存区的指针.\n")])])]),a("h3",{attrs:{id:"自定义程序"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#自定义程序"}},[t._v("#")]),t._v(" 自定义程序")]),t._v(" "),a("p",[t._v("自定义程序一般有以下步骤：")]),t._v(" "),a("ul",[a("li",[t._v("创建一个程序对象 --"),a("code",[t._v("glCreateProgram")]),t._v("​")]),t._v(" "),a("li",[t._v("着色器与程序连接/附着 --"),a("code",[t._v("glAttachShader")]),t._v("​")]),t._v(" "),a("li",[t._v("链接程序 --"),a("code",[t._v("glLinkProgram")]),t._v("​")]),t._v(" "),a("li",[t._v("使用程序 --"),a("code",[t._v("glUseProgram")]),t._v("​")])]),t._v(" "),a("h3",{attrs:{id:"创建与链接程序api"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#创建与链接程序api"}},[t._v("#")]),t._v(" 创建与链接程序API")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("// 创建⼀个程序对象\nGLUint glCreateProgram( )\n// 返回值: 返回⼀个执行新程序对象的句句柄\n\nvoid glDeleteProgram( GLuint program ) \n// program : 指向需要删除的程序对象句柄\n\n// 着⾊器与程序连接/附着\nvoid glAttachShader( GLuint program , GLuint shader );\n// program : 指向程序对象的句柄\n// shader : 指向程序连接的着⾊器对象的句柄\n\n// 断开连接\nvoid glDetachShader(GLuint program);\n// program : 指向程序对象的句柄\n// shader : 指向程序断开连接的着⾊器对象句柄\n\n// 链接程序\nglLinkProgram(GLuint program) \n// program: 指向程序对象句柄\n\n// 检查链接是否成功\nvoid glGetProgramiv (GLuint program,GLenum pname, GLint *params);\n// program: 需要获取信息的程序对象句柄 \n// pname : 获取信息的参数,可以是:\n\t\t\tGL_ACTIVE_ATTRIBUTES \n\t\t\tGL_ACTIVE_ATTRIBUTES_MAX_LENGTH \n\t\t\tGL_ACTIVE_UNIFORM_BLOCK \n\t\t\tGL_ACTIVE_UNIFORM_BLOCK_MAX_LENGTH \n\t\t\tGL_ACTIVE_UNIFROMS \n\t\t\tGL_ACTIVE_UNIFORM_MAX_LENGTH \n\t\t\tGL_ATTACHED_SHADERS \n\t\t\tGL_DELETE_STATUS\n\t\t\tGL_INFO_LOG_LENGTH\n\t\t\tGL_LINK_STATUS \n\t\t\tGL_PROGRAM_BINARY_RETRIEVABLE_HINT \n\t\t\tGL_TRANSFORM_FEEDBACK_BUFFER_MODE \n\t\t\tGL_TRANSFORM_FEEDBACK_VARYINGS \n\t\t\tGL_TRANSFORM_FEEDBACK_VARYING_MAX_LENGTH \n\t\t\tGL_VALIDATE_STATUS\n// params : 指向查询结果整数存储位置的指针\n\n// 从程序信息日志中获取信息\nvoid glGetPorgramInfoLog( GLuint program ,GLSizei maxLength, GLSizei *length , GLChar *infoLog )\n// program : 指向需要获取信息的程序对象句柄\n// maxLength : 存储信息⽇志的缓存区⼤小\n// length : 写⼊的信息日志⻓度(减去null 终⽌止符),如果不需要知道长度,这个参数可以为Null. infoLog : 指向存储信息⽇志的字符缓存区的指针\n\n// 使用程序\nvoid glUseProgram(GLuint program) \n// program: 设置为活动程序的程序对象句柄.\n")])])]),a("h2",{attrs:{id:"基础语法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#基础语法"}},[t._v("#")]),t._v(" 基础语法")]),t._v(" "),a("p",[t._v("变量和数据类型")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("// 布尔型. true,false; \nbool bDone = false;\n\n// 有符号整型数据\nint iValue = 42;\n\n//无符号整形\nuint uiValue = 3929u;\n\n//浮点型\nfloat fValue = 3.14159f;\n")])])]),a("p",[t._v("向量数据类型")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("//1. 向量声明--4分量的float 类型向量; \nvec4 V1;\n\n//2. 生命向量并对其进行构造\nvec4 V2 = vec4(1,2,3,4);\n\n//3. 向量运算,加,赋值给另外一个向量，与标量相乘 \nvec4 v;\nvec4 vOldPos = vec4(1,2,3,4);\nvec4 vOffset = vec4(1,2,3,4);\n\n// 所有参与运算的变量需要对齐定义且赋值\nv = vOldPos + vOffset;\nv = vNewPos;\nv += vec4(10,10,10,10);\nv = vOldPos * vOffset;\nv *= 5;\n\n//4. 向量中元素的获取 可以通过x,y,z,w来获取向量中的元素值 \nv1.x = 3.0f;\nv1.xy = vec2(3.0f,4.0f);\nv1.xyz = vec3(3,0f,4,0f,5.0f);\n\n//5. 颜色控制.r,g,b,a\nv1.r = 3.0f;\nv1.rgba = vec4(1.0f,1.0f,1.0f,1.0f);\n\n//6.纹理坐标stpq; \nv1.st = vec2(1.0f,0.0f);\n\n//7.赋值混合不合法\nv1.st = v2.xt; //不可以\nv1.st = v2.xy; //可以, 但没有意义!\n\n//8.向量支持调换(swizzle)操作. 2个或2个以上向量元素进行交换. \nv1.rgba = v2.bgra;\nv2.bgra = v1.rgba;\n\n//赋值操作 \nv1.r = v2.b; \nv1.g = v2.g; \nv1.b = v2.r; \nv1.a = v2.a;\n\n//9.向量还支持一次性对所有分量操作\nv1.x = vOtherVerex.x +5.0f; \nv1.y = vOtherVerex.y +4.0f; \nv1.z = vOtherVerex.z +3.0f;\n\nv1.xyz = vOtherVerex.xyz + vec3(5.0f,4.0f,3.0f);\n")])])]),a("p",[t._v("矩阵")]),t._v(" "),a("div",{staticClass:"language-glsl extra-class"},[a("pre",{pre:!0,attrs:{class:"language-glsl"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//1.创建矩阵")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("mat4")]),t._v(" m1"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("m2"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("m3"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//2.构造单元矩阵")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("mat4")]),t._v(" m2 "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("mat4")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("\n            "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1.0f")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0.0f")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0.0f")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0.0f")]),t._v("\n            "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0.0f")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1.0f")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0.0f")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0.0f")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n            "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0.0f")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0.0f")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1.0f")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0.0f")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n            "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0.0f")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0.0f")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0.0f")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1.0f")]),t._v("\n\t\t\t\t\t"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("mat4")]),t._v(" m4 "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("mat4")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1.0f")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("mat4")]),t._v(" m3 "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("mat4")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("\n  \t\t\t\t\t"),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0.5")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0.5")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0.5")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0.5")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n            "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0.5")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0.5")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0.5")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0.5")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n            "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0.5")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0.5")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0.5")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0.5")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n            "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0.5")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0.5")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0.5")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0.5")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n  \t\t\t\t"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//2.")]),t._v("\nm1 "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" m2 "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" m3"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),a("p",[t._v("const")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v(" const float zero = 0.0;\n")])])]),a("p",[t._v("结构体")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("struct forStruct{\n vec4 color;\n float start;\n float end;\n}fogVar;\nfogVar = fogStruct(vec4(1.0,0.0,0.0,1.0),0.5,2.0);\nvec4 color = fogVar.color;\nfloat start = fogVar.start;\n")])])]),a("p",[t._v("数组")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("float floatArray[4];\nvec4 vecArray[2];\n//注意\nfloat a[4] = float[](1.0,2.0,3.0,4.0);\nvec2 c[2] = vec2[2](vec2(1.0,2.0),vec2(3.0,4.0));\n")])])]),a("p",[t._v("函数")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("定义函数给三个修饰符.\nin: (默认), 传入函数中，函数不能对其进行修改\ninout: 可以在函数中修改\nout : 函数返回时，可以将其修改\n\nvec4 myFunc(inout float myFloat, out vec4 m1, mat4 m2){\n\n}\n\nvec4 diffuse(vec3 normal ,vec3 light, vec4 baseColor) {\n\treturn baseColor * dot(normal,light); \n}\n\n// GLSL 函数中没有递归\n")])])]),a("p",[t._v("控制语句")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("if(color.a < 0.25)\n  {\n      color *= color.a;\n  }else\n  {\n      color = vec4(1.0,1.0,1.0,1.0);\n}\n//循环只支持 while 循环 / do while / for\n openGL ES 开发中应尽量减少逻辑判断。降低循环迭代使用\n")])])])])}),[],!1,null,null,null);a.default=e.exports}}]);