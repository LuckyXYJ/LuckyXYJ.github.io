(window.webpackJsonp=window.webpackJsonp||[]).push([[38],{339:function(a,t,v){"use strict";v.r(t);var e=v(6),r=Object(e.a)({},(function(){var a=this,t=a._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("h2",{attrs:{id:"访问控制"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#访问控制"}},[a._v("#")]),a._v(" 访问控制")]),a._v(" "),t("p",[a._v("在访问权限控制这块，Swift提供了5个不同的访问级别（以下是从高到低排列， 实体指被访问级别修饰的内容）")]),a._v(" "),t("ul",[t("li",[a._v("open：允许在定义实体的模块、其他模块中访问，允许其他模块进行继承、重写（open只能用在类、类成员上）")]),a._v(" "),t("li",[a._v("public：允许在定义实体的模块、其他模块中访问，不允许其他模块进行继承、重写")]),a._v(" "),t("li",[a._v("internal：只允许在定义实体的模块中访问，不允许在其他模块中访问")]),a._v(" "),t("li",[a._v("fileprivate：只允许在定义实体的源文件中访问")]),a._v(" "),t("li",[a._v("private：只允许在定义实体的封闭声明中访问")])]),a._v(" "),t("p",[a._v("绝大部分实体默认都是 internal 级别")]),a._v(" "),t("p",[a._v("直接在全局作用域下定义的private等价于fileprivate")]),a._v(" "),t("h2",{attrs:{id:"访问级别的使用准则"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#访问级别的使用准则"}},[a._v("#")]),a._v(" 访问级别的使用准则")]),a._v(" "),t("p",[a._v("一个实体不可以被更低访问级别的实体定义，比如")]),a._v(" "),t("ul",[t("li",[a._v("变量\\常量类型 ≥ 变量\\常量")]),a._v(" "),t("li",[a._v("参数类型、返回值类型 ≥ 函数")]),a._v(" "),t("li",[a._v("父类 ≥ 子类")]),a._v(" "),t("li",[a._v("父协议 ≥ 子协议")]),a._v(" "),t("li",[a._v("原类型 ≥ typealias")]),a._v(" "),t("li",[a._v("原始值类型、关联值类型 ≥ 枚举类型")]),a._v(" "),t("li",[a._v("定义类型A时用到的其他类型 ≥ 类型A")]),a._v(" "),t("li",[a._v("......")])]),a._v(" "),t("h2",{attrs:{id:"元组类型"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#元组类型"}},[a._v("#")]),a._v(" 元组类型")]),a._v(" "),t("p",[a._v("元组类型的访问级别是所有成员类型最低的那个")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("internal struct Dog {} \nfileprivate class Person {}\n\n// (Dog, Person)的访问级别是fileprivate \nfileprivate var data1: (Dog, Person) \nprivate var data2: (Dog, Person)\n")])])]),t("h2",{attrs:{id:"泛型类型"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#泛型类型"}},[a._v("#")]),a._v(" 泛型类型")]),a._v(" "),t("p",[a._v("泛型类型的访问级别是 类型的访问级别 以及 所有泛型类型参数的访问级别 中最低的那个")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("internal class Car {} \nfileprivate class Dog {} \npublic class Person<T1, T2> {}\n\n// Person<Car, Dog>的访问级别是\nfileprivate fileprivate var p = Person<Car, Dog>()\n")])])]),t("h2",{attrs:{id:"成员-嵌套类型"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#成员-嵌套类型"}},[a._v("#")]),a._v(" 成员，嵌套类型")]),a._v(" "),t("p",[a._v("类型的访问级别会影响成员（属性、方法、初始化器、下标）、嵌套类型的默认访问级别")]),a._v(" "),t("ul",[t("li",[a._v("一般情况下，类型为private或fileprivate，那么成员\\嵌套类型默认也是private或fileprivate")]),a._v(" "),t("li",[a._v("一般情况下，类型为internal或public，那么成员\\嵌套类型默认是internal")])]),a._v(" "),t("h2",{attrs:{id:"成员的重写"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#成员的重写"}},[a._v("#")]),a._v(" 成员的重写")]),a._v(" "),t("p",[a._v("子类重写成员的访问级别必须 ≥ 子类的访问级别，或者 ≥ 父类被重写成员的访问级别")]),a._v(" "),t("p",[a._v("父类的成员不能被成员作用域外定义的子类重写")]),a._v(" "),t("h2",{attrs:{id:"getter、setter"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#getter、setter"}},[a._v("#")]),a._v(" getter、setter")]),a._v(" "),t("p",[a._v("getter、setter默认自动接收它们所属环境的访问级别")]),a._v(" "),t("p",[a._v("可以给setter单独设置一个比getter更低的访问级别，用以限制写的权限")]),a._v(" "),t("h2",{attrs:{id:"初始化器"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#初始化器"}},[a._v("#")]),a._v(" 初始化器")]),a._v(" "),t("p",[a._v("如果一个public类想在另一个模块调用编译生成的默认无参初始化器，必须显式提供public的无参初始化器")]),a._v(" "),t("p",[a._v("因为"),t("strong",[a._v("public类的默认初始化器是internal级别")])]),a._v(" "),t("p",[a._v("required初始化器 ≥ 它的默认访问级别")]),a._v(" "),t("p",[a._v("如果结构体有private\\fileprivate的存储实例属性，那么它的成员初始化器也是")]),a._v(" "),t("p",[a._v("private\\fileprivate 否则默认就是internal")]),a._v(" "),t("h2",{attrs:{id:"枚举类型的case"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#枚举类型的case"}},[a._v("#")]),a._v(" 枚举类型的case")]),a._v(" "),t("p",[a._v("不能给enum的每个case单独设置访问级别")]),a._v(" "),t("p",[a._v("每个case自动接收enum的访问级别")]),a._v(" "),t("p",[a._v("public enum定义的case也是public")]),a._v(" "),t("h2",{attrs:{id:"协议"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#协议"}},[a._v("#")]),a._v(" 协议")]),a._v(" "),t("p",[a._v("协议中定义的要求自动接收协议的访问级别，不能单独设置访问级别")]),a._v(" "),t("p",[a._v("public协议定义的要求也是public")]),a._v(" "),t("p",[a._v("协议实现的访问级别必须 ≥ 类型的访问级别，或者 ≥ 协议的访问级别")]),a._v(" "),t("h2",{attrs:{id:"扩展"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#扩展"}},[a._v("#")]),a._v(" 扩展")]),a._v(" "),t("p",[a._v("如果有显式设置扩展的访问级别，扩展添加的成员自动接收扩展的访问级别")]),a._v(" "),t("p",[a._v("如果没有显式设置扩展的访问级别，扩展添加的成员的默认访问级别，跟直接在类型中定义的成员一样")]),a._v(" "),t("p",[a._v("可以单独给扩展添加的成员设置访问级别")]),a._v(" "),t("p",[a._v("不能给用于遵守协议的扩展显式设置扩展的访问级别")]),a._v(" "),t("p",[a._v("在同一文件中的扩展，可以写成类似多个部分的类型声明")]),a._v(" "),t("ul",[t("li",[a._v("在原本的声明中声明一个私有成员，可以在同一文件的扩展中访问它")]),a._v(" "),t("li",[a._v("在扩展中声明一个私有成员，可以在同一文件的其他扩展中、原本声明中访问它")])])])}),[],!1,null,null,null);t.default=r.exports}}]);